---
phase: 05-pool-factory-and-duckdb-integration
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/adbc_poolhouse/_exceptions.py
  - src/adbc_poolhouse/_base_config.py
  - src/adbc_poolhouse/_duckdb_config.py
autonomous: true
requirements:
  - POOL-05
  - TEST-02

must_haves:
  truths:
    - "PoolhouseError and ConfigurationError are importable from adbc_poolhouse._exceptions"
    - "ConfigurationError is a subclass of both PoolhouseError and ValueError"
    - "DuckDBConfig raises ConfigurationError (not bare ValueError) for :memory: + pool_size > 1"
    - "DuckDBConfig._adbc_entrypoint() returns 'duckdb_adbc_init'"
    - "BaseWarehouseConfig._adbc_entrypoint() returns None"
    - "WarehouseConfig Protocol includes _adbc_entrypoint() method signature"
    - "prek passes with no violations after all changes"
  artifacts:
    - path: "src/adbc_poolhouse/_exceptions.py"
      provides: "PoolhouseError base + ConfigurationError dual-inherit"
      contains: "class PoolhouseError(Exception)"
    - path: "src/adbc_poolhouse/_base_config.py"
      provides: "WarehouseConfig Protocol + BaseWarehouseConfig with _adbc_entrypoint"
      contains: "_adbc_entrypoint"
    - path: "src/adbc_poolhouse/_duckdb_config.py"
      provides: "DuckDBConfig updated to use ConfigurationError + _adbc_entrypoint"
      contains: "duckdb_adbc_init"
  key_links:
    - from: "src/adbc_poolhouse/_duckdb_config.py"
      to: "src/adbc_poolhouse/_exceptions.py"
      via: "from adbc_poolhouse._exceptions import ConfigurationError"
      pattern: "ConfigurationError"
    - from: "src/adbc_poolhouse/_pool_factory.py"
      to: "src/adbc_poolhouse/_base_config.py"
      via: "config._adbc_entrypoint()"
      pattern: "_adbc_entrypoint"
---

<objective>
Build the exception hierarchy and update the config layer as the foundation for the pool factory.

Purpose: The pool factory (Plan 02) needs `ConfigurationError` for validation and `_adbc_entrypoint()` on configs for DuckDB driver resolution. These foundational changes must land first.
Output: `_exceptions.py` (PoolhouseError + ConfigurationError), updated `_base_config.py` (Protocol + base class with `_adbc_entrypoint`), updated `_duckdb_config.py` (raises `ConfigurationError`, overrides `_adbc_entrypoint`).
</objective>

<execution_context>
@/Users/paul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/paul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pool-factory-and-duckdb-integration/05-CONTEXT.md
@.planning/phases/05-pool-factory-and-duckdb-integration/05-RESEARCH.md
@src/adbc_poolhouse/_base_config.py
@src/adbc_poolhouse/_duckdb_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exception hierarchy (_exceptions.py)</name>
  <files>src/adbc_poolhouse/_exceptions.py</files>
  <action>
Create `src/adbc_poolhouse/_exceptions.py` with two classes:

```python
"""Custom exceptions for adbc-poolhouse."""


class PoolhouseError(Exception):
    """
    Base exception for all adbc-poolhouse errors.

    All library-specific exceptions inherit from this class.
    Consumers can use ``except PoolhouseError`` to catch any library error.
    """


class ConfigurationError(PoolhouseError, ValueError):
    """
    Raised when a config model contains invalid field values.

    Inherits from both PoolhouseError (library hierarchy) and ValueError
    (pydantic model_validator compatibility). When raised inside a pydantic
    @model_validator, pydantic wraps it in ValidationError — which itself
    inherits from ValueError — satisfying 'raises ValueError' test expectations.

    Example::

        DuckDBConfig(database=":memory:", pool_size=2)
        # raises pydantic.ValidationError (which wraps ConfigurationError,
        # and ValidationError itself inherits from ValueError)
    """
```

This is a new file. Internal module — do NOT add to `__init__.py` yet (that's Plan 02's job for `PoolhouseError` and `ConfigurationError` public exports).
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && uv run python -c "from adbc_poolhouse._exceptions import PoolhouseError, ConfigurationError; assert issubclass(ConfigurationError, PoolhouseError); assert issubclass(ConfigurationError, ValueError); print('OK')"</automated>
  </verify>
  <done>PoolhouseError and ConfigurationError are importable; ConfigurationError is a subclass of both PoolhouseError and ValueError; issubclass checks pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add _adbc_entrypoint to BaseWarehouseConfig and WarehouseConfig Protocol</name>
  <files>src/adbc_poolhouse/_base_config.py</files>
  <action>
Update `src/adbc_poolhouse/_base_config.py` to add `_adbc_entrypoint()` in two places:

1. **WarehouseConfig Protocol** — add method signature:
```python
def _adbc_entrypoint(self) -> str | None: ...
```
Add it after the existing pool tuning field declarations in the Protocol body.

2. **BaseWarehouseConfig** — add concrete method that returns None (default; DuckDB will override):
```python
def _adbc_entrypoint(self) -> str | None:
    """
    Return the ADBC entry-point symbol, or None if not required.

    DuckDB overrides this to return ``'duckdb_adbc_init'``.
    All other drivers do not need an explicit entry point.

    Internal only — not part of the public API.
    """
    return None
```
Add this method to `BaseWarehouseConfig` after the `_adbc_driver_key()` abstract method. It is NOT abstract (default implementation returns None).

No new imports are needed. The method signature uses `str | None` which is already valid with `from __future__ import annotations` (add that import at the top if not already present).
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && uv run python -c "from adbc_poolhouse._base_config import WarehouseConfig, BaseWarehouseConfig; from adbc_poolhouse import DuckDBConfig; cfg = DuckDBConfig(); print('base entrypoint:', cfg._adbc_entrypoint())"</automated>
  </verify>
  <done>BaseWarehouseConfig._adbc_entrypoint() exists and is callable; default returns None; WarehouseConfig Protocol includes _adbc_entrypoint in its definition.</done>
</task>

<task type="auto">
  <name>Task 3: Update DuckDBConfig to use ConfigurationError and override _adbc_entrypoint</name>
  <files>src/adbc_poolhouse/_duckdb_config.py</files>
  <action>
Update `src/adbc_poolhouse/_duckdb_config.py` with two changes:

1. **Import ConfigurationError** at module level (it's used at runtime in model_validator):
```python
from adbc_poolhouse._exceptions import ConfigurationError
```
This import should NOT go in a TYPE_CHECKING block — it's used at runtime inside the validator.

2. **Replace `raise ValueError(...)` with `raise ConfigurationError(...)`** in `check_memory_pool_size`:
```python
@model_validator(mode="after")
def check_memory_pool_size(self) -> Self:
    if self.database == ":memory:" and self.pool_size > 1:
        raise ConfigurationError(
            'pool_size > 1 with database=":memory:" will give each pool '
            "connection an isolated in-memory database (each connection "
            "sees a different empty DB, so shared state is impossible). "
            "Use pool_size=1 for in-memory DuckDB, or set database to a "
            "file path for shared state across connections."
        )
    return self
```

3. **Add _adbc_entrypoint override** after `_adbc_driver_key()`:
```python
def _adbc_entrypoint(self) -> str | None:
    return "duckdb_adbc_init"
```

Run `uv run prek` after changes. If ruff flags the ConfigurationError import with TC001 (move to TYPE_CHECKING), do NOT do it — the import is runtime-required for the model_validator. Add `# noqa: TC001` if needed (same pattern as SecretStr in other configs).
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && uv run pytest tests/test_configs.py::TestDuckDBConfig::test_memory_pool_size_validator_fires -x --tb=short &amp;&amp; uv run python -c "from adbc_poolhouse import DuckDBConfig; cfg = DuckDBConfig(); assert cfg._adbc_entrypoint() == 'duckdb_adbc_init'; print('OK')" &amp;&amp; uv run prek --hook-stage manual 2&gt;&amp;1 | tail -5</automated>
  </verify>
  <done>test_memory_pool_size_validator_fires passes (ValidationError raised for :memory: + pool_size=2); DuckDBConfig._adbc_entrypoint() returns 'duckdb_adbc_init'; prek passes.</done>
</task>

</tasks>

<verification>
Run full test suite to confirm no regressions:
`cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && uv run pytest tests/ -x --tb=short`

All existing tests must remain green. The only behavioral change is `ConfigurationError` (which inherits from `ValueError`) replacing bare `ValueError` in DuckDBConfig — pydantic wraps both in `ValidationError`, so existing tests using `pytest.raises(ValidationError)` continue to pass.
</verification>

<success_criteria>
- `_exceptions.py` exists with PoolhouseError and ConfigurationError
- `issubclass(ConfigurationError, ValueError)` is True
- `issubclass(ConfigurationError, PoolhouseError)` is True
- `DuckDBConfig._adbc_entrypoint()` returns `'duckdb_adbc_init'`
- `BaseWarehouseConfig._adbc_entrypoint()` returns `None` (other configs inherit this)
- `WarehouseConfig` Protocol includes `_adbc_entrypoint` method signature
- All existing tests pass (`uv run pytest tests/ -x`)
- prek passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/05-pool-factory-and-duckdb-integration/05-01-SUMMARY.md`
</output>
