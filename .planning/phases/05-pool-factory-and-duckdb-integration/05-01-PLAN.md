---
phase: 05-pool-factory-and-duckdb-integration
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/adbc_poolhouse/_exceptions.py
  - src/adbc_poolhouse/_base_config.py
  - src/adbc_poolhouse/_duckdb_config.py
autonomous: true
requirements:
  - POOL-05
  - TEST-02

must_haves:
  truths:
    - "PoolhouseError and ConfigurationError are importable from adbc_poolhouse._exceptions"
    - "ConfigurationError is a subclass of both PoolhouseError and ValueError"
    - "DuckDBConfig raises ConfigurationError (not bare ValueError) for :memory: + pool_size > 1"
    - "DuckDBConfig raises ConfigurationError for pool_size <= 0, max_overflow < 0, timeout <= 0, recycle <= 0, database empty/None"
    - "Error messages include the invalid value (e.g. 'pool_size must be > 0, got -1')"
    - "DuckDBConfig._adbc_entrypoint() returns 'duckdb_adbc_init'"
    - "BaseWarehouseConfig._adbc_entrypoint() returns None"
    - "WarehouseConfig Protocol includes _adbc_entrypoint() method signature"
    - "prek passes with no violations after all changes"
  artifacts:
    - path: "src/adbc_poolhouse/_exceptions.py"
      provides: "PoolhouseError base + ConfigurationError dual-inherit"
      contains: "class PoolhouseError(Exception)"
    - path: "src/adbc_poolhouse/_base_config.py"
      provides: "WarehouseConfig Protocol + BaseWarehouseConfig with _adbc_entrypoint"
      contains: "_adbc_entrypoint"
    - path: "src/adbc_poolhouse/_duckdb_config.py"
      provides: "DuckDBConfig updated to use ConfigurationError + _adbc_entrypoint + bounds validators"
      contains: "duckdb_adbc_init"
  key_links:
    - from: "src/adbc_poolhouse/_duckdb_config.py"
      to: "src/adbc_poolhouse/_exceptions.py"
      via: "from adbc_poolhouse._exceptions import ConfigurationError"
      pattern: "ConfigurationError"
    - from: "src/adbc_poolhouse/_pool_factory.py"
      to: "src/adbc_poolhouse/_base_config.py"
      via: "config._adbc_entrypoint()"
      pattern: "_adbc_entrypoint"
---

<objective>
Build the exception hierarchy and update the config layer as the foundation for the pool factory.

Purpose: The pool factory (Plan 02) needs `ConfigurationError` for validation and `_adbc_entrypoint()` on configs for DuckDB driver resolution. These foundational changes must land first.
Output: `_exceptions.py` (PoolhouseError + ConfigurationError), updated `_base_config.py` (Protocol + base class with `_adbc_entrypoint`), updated `_duckdb_config.py` (raises `ConfigurationError`, overrides `_adbc_entrypoint`, adds five bounds validators).
</objective>

<execution_context>
@/Users/paul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/paul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pool-factory-and-duckdb-integration/05-CONTEXT.md
@.planning/phases/05-pool-factory-and-duckdb-integration/05-RESEARCH.md
@src/adbc_poolhouse/_base_config.py
@src/adbc_poolhouse/_duckdb_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exception hierarchy (_exceptions.py)</name>
  <files>src/adbc_poolhouse/_exceptions.py</files>
  <action>
Create `src/adbc_poolhouse/_exceptions.py` with two classes:

```python
"""Custom exceptions for adbc-poolhouse."""


class PoolhouseError(Exception):
    """
    Base exception for all adbc-poolhouse errors.

    All library-specific exceptions inherit from this class.
    Consumers can use ``except PoolhouseError`` to catch any library error.
    """


class ConfigurationError(PoolhouseError, ValueError):
    """
    Raised when a config model contains invalid field values.

    Inherits from both PoolhouseError (library hierarchy) and ValueError
    (pydantic model_validator compatibility). When raised inside a pydantic
    @model_validator, pydantic wraps it in ValidationError — which itself
    inherits from ValueError — satisfying 'raises ValueError' test expectations.

    Example::

        DuckDBConfig(database=":memory:", pool_size=2)
        # raises pydantic.ValidationError (which wraps ConfigurationError,
        # and ValidationError itself inherits from ValueError)
    """
```

This is a new file. Internal module — do NOT add to `__init__.py` yet (that's Plan 02's job for `PoolhouseError` and `ConfigurationError` public exports).
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && uv run python -c "from adbc_poolhouse._exceptions import PoolhouseError, ConfigurationError; assert issubclass(ConfigurationError, PoolhouseError); assert issubclass(ConfigurationError, ValueError); print('OK')"</automated>
  </verify>
  <done>PoolhouseError and ConfigurationError are importable; ConfigurationError is a subclass of both PoolhouseError and ValueError; issubclass checks pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add _adbc_entrypoint to BaseWarehouseConfig and WarehouseConfig Protocol</name>
  <files>src/adbc_poolhouse/_base_config.py</files>
  <action>
Update `src/adbc_poolhouse/_base_config.py` to add `_adbc_entrypoint()` in two places:

1. **WarehouseConfig Protocol** — add method signature:
```python
def _adbc_entrypoint(self) -> str | None: ...
```
Add it after the existing pool tuning field declarations in the Protocol body.

2. **BaseWarehouseConfig** — add concrete method that returns None (default; DuckDB will override):
```python
def _adbc_entrypoint(self) -> str | None:
    """
    Return the ADBC entry-point symbol, or None if not required.

    DuckDB overrides this to return ``'duckdb_adbc_init'``.
    All other drivers do not need an explicit entry point.

    Internal only — not part of the public API.
    """
    return None
```
Add this method to `BaseWarehouseConfig` after the `_adbc_driver_key()` abstract method. It is NOT abstract (default implementation returns None).

No new imports are needed. The method signature uses `str | None` which is already valid with `from __future__ import annotations` (add that import at the top if not already present).
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && uv run python -c "
from adbc_poolhouse._base_config import BaseWarehouseConfig, WarehouseConfig
from adbc_poolhouse import DuckDBConfig

# Verify DuckDB override returns the expected entrypoint
cfg = DuckDBConfig()
assert cfg._adbc_entrypoint() == 'duckdb_adbc_init', f'Expected duckdb_adbc_init, got {cfg._adbc_entrypoint()!r}'

# Verify the base class default returns None via a minimal concrete subclass
class _MinimalConfig(BaseWarehouseConfig):
    def _adbc_driver_key(self) -> str:
        return 'test'

base_cfg = _MinimalConfig()
assert base_cfg._adbc_entrypoint() is None, f'Expected None, got {base_cfg._adbc_entrypoint()!r}'

print('OK')
"</automated>
  </verify>
  <done>BaseWarehouseConfig._adbc_entrypoint() returns None (verified via a minimal concrete subclass, not via DuckDBConfig which overrides it); DuckDBConfig._adbc_entrypoint() returns 'duckdb_adbc_init'; WarehouseConfig Protocol includes _adbc_entrypoint in its definition.</done>
</task>

<task type="auto">
  <name>Task 3: Update DuckDBConfig to use ConfigurationError, override _adbc_entrypoint, and add bounds validators</name>
  <files>src/adbc_poolhouse/_duckdb_config.py</files>
  <action>
Update `src/adbc_poolhouse/_duckdb_config.py` with four changes:

1. **Import ConfigurationError** at module level (it's used at runtime in validators):
```python
from adbc_poolhouse._exceptions import ConfigurationError
```
This import should NOT go in a TYPE_CHECKING block — it's used at runtime inside validators. Add `# noqa: TC001` if ruff flags it with TC001 (same pattern as SecretStr in other configs).

2. **Add `field_validator` import** from pydantic alongside the existing `model_validator`:
```python
from pydantic import field_validator, model_validator
```

3. **Add five field validators** for the locked decisions from CONTEXT.md. Add these as class-level methods before `check_memory_pool_size`. Each raises `ConfigurationError` with a message that includes the invalid value:

```python
@field_validator("pool_size")
@classmethod
def validate_pool_size(cls, v: int) -> int:
    if v <= 0:
        raise ConfigurationError(f"pool_size must be > 0, got {v}")
    return v

@field_validator("max_overflow")
@classmethod
def validate_max_overflow(cls, v: int) -> int:
    if v < 0:
        raise ConfigurationError(f"max_overflow must be >= 0, got {v}")
    return v

@field_validator("timeout")
@classmethod
def validate_timeout(cls, v: int) -> int:
    if v <= 0:
        raise ConfigurationError(f"timeout must be > 0, got {v}")
    return v

@field_validator("recycle")
@classmethod
def validate_recycle(cls, v: int) -> int:
    if v <= 0:
        raise ConfigurationError(f"recycle must be > 0, got {v}")
    return v

@field_validator("database")
@classmethod
def validate_database(cls, v: str) -> str:
    if not v or not v.strip():
        raise ConfigurationError(
            f"database must be a non-empty string, got {v!r}"
        )
    return v
```

Note: `pool_size` has a default of `1` in `DuckDBConfig` (overrides the base class default of `5`), and the validator allows `pool_size=1` — only zero and negative values are rejected.

4. **Replace `raise ValueError(...)` with `raise ConfigurationError(...)`** in `check_memory_pool_size`:
```python
@model_validator(mode="after")
def check_memory_pool_size(self) -> Self:
    if self.database == ":memory:" and self.pool_size > 1:
        raise ConfigurationError(
            'pool_size > 1 with database=":memory:" will give each pool '
            "connection an isolated in-memory database (each connection "
            "sees a different empty DB, so shared state is impossible). "
            "Use pool_size=1 for in-memory DuckDB, or set database to a "
            "file path for shared state across connections."
        )
    return self
```

5. **Add _adbc_entrypoint override** after `_adbc_driver_key()`:
```python
def _adbc_entrypoint(self) -> str | None:
    return "duckdb_adbc_init"
```

Run `uv run prek` after changes to confirm no violations.
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && uv run python -c "
from pydantic import ValidationError
from adbc_poolhouse import DuckDBConfig
from adbc_poolhouse._exceptions import ConfigurationError

# _adbc_entrypoint override
cfg = DuckDBConfig()
assert cfg._adbc_entrypoint() == 'duckdb_adbc_init'

# :memory: + pool_size > 1 still raises
try:
    DuckDBConfig(database=':memory:', pool_size=2)
    assert False, 'Should have raised'
except ValidationError:
    pass

# pool_size <= 0
try:
    DuckDBConfig(pool_size=0)
    assert False, 'Should have raised for pool_size=0'
except ValidationError:
    pass

try:
    DuckDBConfig(pool_size=-1)
    assert False, 'Should have raised for pool_size=-1'
except ValidationError:
    pass

# max_overflow < 0
try:
    DuckDBConfig(max_overflow=-1)
    assert False, 'Should have raised for max_overflow=-1'
except ValidationError:
    pass

# timeout <= 0
try:
    DuckDBConfig(timeout=0)
    assert False, 'Should have raised for timeout=0'
except ValidationError:
    pass

# recycle <= 0
try:
    DuckDBConfig(recycle=0)
    assert False, 'Should have raised for recycle=0'
except ValidationError:
    pass

# database empty string
try:
    DuckDBConfig(database='')
    assert False, 'Should have raised for database empty'
except ValidationError:
    pass

print('OK — all validators fire correctly')
" && uv run prek --hook-stage manual 2>&1 | tail -5</automated>
  </verify>
  <done>test_memory_pool_size_validator_fires passes; DuckDBConfig._adbc_entrypoint() returns 'duckdb_adbc_init'; all five bounds validators fire (pool_size <= 0, max_overflow < 0, timeout <= 0, recycle <= 0, database empty); error messages include the invalid value; prek passes.</done>
</task>

</tasks>

<verification>
Run full test suite to confirm no regressions:
`cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && uv run pytest tests/ -x --tb=short`

All existing tests must remain green. The only behavioral change is `ConfigurationError` (which inherits from `ValueError`) replacing bare `ValueError` in DuckDBConfig — pydantic wraps both in `ValidationError`, so existing tests using `pytest.raises(ValidationError)` continue to pass.
</verification>

<success_criteria>
- `_exceptions.py` exists with PoolhouseError and ConfigurationError
- `issubclass(ConfigurationError, ValueError)` is True
- `issubclass(ConfigurationError, PoolhouseError)` is True
- `DuckDBConfig._adbc_entrypoint()` returns `'duckdb_adbc_init'`
- `BaseWarehouseConfig._adbc_entrypoint()` returns `None` (verified via minimal concrete subclass)
- `WarehouseConfig` Protocol includes `_adbc_entrypoint` method signature
- `DuckDBConfig(pool_size=0)` raises `ValidationError` (ConfigurationError inside)
- `DuckDBConfig(pool_size=-1)` raises `ValidationError` (ConfigurationError inside)
- `DuckDBConfig(max_overflow=-1)` raises `ValidationError` (ConfigurationError inside)
- `DuckDBConfig(timeout=0)` raises `ValidationError` (ConfigurationError inside)
- `DuckDBConfig(recycle=0)` raises `ValidationError` (ConfigurationError inside)
- `DuckDBConfig(database='')` raises `ValidationError` (ConfigurationError inside)
- Error messages include the invalid value (e.g. `"pool_size must be > 0, got -1"`)
- All existing tests pass (`uv run pytest tests/ -x`)
- prek passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/05-pool-factory-and-duckdb-integration/05-01-SUMMARY.md`
</output>
