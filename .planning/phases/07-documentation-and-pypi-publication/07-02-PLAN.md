---
phase: 07-documentation-and-pypi-publication
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/adbc_poolhouse/_base_config.py
  - src/adbc_poolhouse/_duckdb_config.py
  - src/adbc_poolhouse/_snowflake_config.py
  - src/adbc_poolhouse/_bigquery_config.py
  - src/adbc_poolhouse/_postgresql_config.py
  - src/adbc_poolhouse/_flightsql_config.py
  - src/adbc_poolhouse/_databricks_config.py
  - src/adbc_poolhouse/_redshift_config.py
  - src/adbc_poolhouse/_trino_config.py
  - src/adbc_poolhouse/_mssql_config.py
  - src/adbc_poolhouse/_exceptions.py
autonomous: true
requirements:
  - DOCS-01

must_haves:
  truths:
    - "All public classes have a class-level docstring with a one-line summary"
    - "DuckDBConfig and SnowflakeConfig have Examples blocks showing construction"
    - "PoolhouseError and ConfigurationError have docstrings with Raises documented per method"
    - "BaseWarehouseConfig documents all pool tuning fields as attribute docstrings"
    - "mkdocstrings renders field descriptions for all config classes (attribute docstring after each field)"
  artifacts:
    - path: "src/adbc_poolhouse/_base_config.py"
      provides: "BaseWarehouseConfig + WarehouseConfig docstrings"
      contains: "Pool tuning"
    - path: "src/adbc_poolhouse/_duckdb_config.py"
      provides: "DuckDBConfig docstring with Example block"
      contains: "Example:"
    - path: "src/adbc_poolhouse/_snowflake_config.py"
      provides: "SnowflakeConfig docstring with Example block"
      contains: "Example:"
    - path: "src/adbc_poolhouse/_exceptions.py"
      provides: "Exception hierarchy docstrings"
      contains: "PoolhouseError"
  key_links:
    - from: "src/adbc_poolhouse/*.py"
      to: "mkdocstrings renderer"
      via: "attribute docstrings after field assignments"
      pattern: '""".*Env: [A-Z_]+\."""'
---

<objective>
Add Google-style docstrings to all public classes, their public methods, and public module-level functions. Add Examples blocks to key entry points (DuckDBConfig, SnowflakeConfig). Attribute docstrings are already partially present — this plan fills the gaps and adds Examples.

Purpose: DOCS-01 requires all public symbols to be documented so `mkdocstrings` generates a complete API reference. `create_pool` already has full Args/Returns/Raises — this plan covers the config classes and exception hierarchy.
Output: Updated source files with complete Google-style docstrings on all public symbols.
</objective>

<execution_context>
@/Users/paul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/paul/.claude/get-shit-done/templates/summary.md
@.claude/skills/adbc-poolhouse-docs-author/SKILL.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-documentation-and-pypi-publication/07-CONTEXT.md
@.planning/phases/07-documentation-and-pypi-publication/07-RESEARCH.md

<interfaces>
<!-- Public API surface — all names in __all__ that need docstrings -->
<!-- From src/adbc_poolhouse/__init__.py -->
Public names: ConfigurationError, PoolhouseError, WarehouseConfig, BaseWarehouseConfig,
BigQueryConfig, DatabricksConfig, DuckDBConfig, FlightSQLConfig, MSSQLConfig,
PostgreSQLConfig, RedshiftConfig, SnowflakeConfig, TrinoConfig, create_pool

<!-- create_pool already has complete Args/Returns/Raises — verified in RESEARCH.md -->
<!-- Config classes use attribute docstrings (string after field assignment) for fields -->
<!-- mkdocstrings with merge_init_into_class: true renders attribute docstrings as field docs -->

Attribute docstring pattern (already in use — extend this to all missing fields):
```python
class DuckDBConfig(BaseWarehouseConfig):
    """DuckDB warehouse configuration. One-line summary."""
    database: str = ":memory:"
    """File path or ':memory:'. Env: DUCKDB_DATABASE."""
```

Example block pattern (key entry points only):
```python
class DuckDBConfig(BaseWarehouseConfig):
    """
    DuckDB warehouse configuration.

    Covers all DuckDB ADBC connection parameters...

    Example:
        DuckDBConfig(database='/data/warehouse.db', pool_size=5)
        DuckDBConfig()  # in-memory; pool_size=1 enforced by validator
    """
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and complete config class docstrings</name>
  <files>
    src/adbc_poolhouse/_base_config.py
    src/adbc_poolhouse/_duckdb_config.py
    src/adbc_poolhouse/_snowflake_config.py
    src/adbc_poolhouse/_bigquery_config.py
    src/adbc_poolhouse/_postgresql_config.py
    src/adbc_poolhouse/_flightsql_config.py
    src/adbc_poolhouse/_databricks_config.py
    src/adbc_poolhouse/_redshift_config.py
    src/adbc_poolhouse/_trino_config.py
    src/adbc_poolhouse/_mssql_config.py
  </files>
  <action>
Read each config source file. For each public class, verify and fill gaps:

**BaseWarehouseConfig** (`_base_config.py`):
- Class docstring: "Base warehouse configuration with pool tuning fields shared by all warehouse configs."
- Each pool tuning field (`pool_size`, `max_overflow`, `timeout`, `recycle`) must have an attribute docstring: `"""Number of connections to keep open. Default: 5."""` (include the default value)
- WarehouseConfig Protocol: add a one-line class docstring: "Runtime-checkable Protocol for warehouse config objects."

**DuckDBConfig** (`_duckdb_config.py`):
- Class docstring must include an `Example:` block (key entry point per CONTEXT.md):
  ```python
  """
  DuckDB warehouse configuration.

  Covers all DuckDB ADBC connection parameters. Pool tuning fields
  (pool_size, max_overflow, timeout, recycle) are inherited from
  BaseWarehouseConfig and loaded from DUCKDB_* environment variables.

  Example:
      DuckDBConfig(database='/data/warehouse.db', pool_size=5)
      DuckDBConfig()  # in-memory; pool_size=1 enforced by validator
  """
  ```
- All field attribute docstrings present (database field already has one — check all others)

**SnowflakeConfig** (`_snowflake_config.py`):
- Class docstring must include an `Example:` block (key entry point per CONTEXT.md):
  ```python
  """
  Snowflake warehouse configuration.

  Covers all auth methods supported by adbc-driver-snowflake: username/password,
  JWT private key (path or PEM), OAuth, external browser, and username/password/MFA.
  Pool tuning fields are inherited from BaseWarehouseConfig and loaded from
  SNOWFLAKE_* environment variables.

  Example:
      SnowflakeConfig(account='myorg-myaccount', user='me', password='...')
      SnowflakeConfig(account='myorg', user='me', private_key_path=Path('/keys/rsa.p8'))
  """
  ```
- Verify all fields have attribute docstrings; fill any gaps. For SecretStr fields, include `Env: SNOWFLAKE_<FIELD>.` in docstring.

**BigQueryConfig, PostgreSQLConfig, FlightSQLConfig, DatabricksConfig, RedshiftConfig, TrinoConfig, MSSQLConfig** (`_bigquery_config.py` etc.):
- Each class needs a one-line + 2-sentence class docstring covering: what backend it targets, what auth patterns it supports, env_prefix.
- Each field needs an attribute docstring if missing. Minimum: `"""<description>. Env: PREFIX_FIELD."""`
- No Examples block required on these (not key entry points per CONTEXT.md).

**Do NOT** add `__init__` docstrings — `merge_init_into_class: true` is active; attribute docstrings are the correct pattern.

**Humanizer pass:** Review all new prose. Eliminate "powerful", "seamlessly", "leverage", "it's worth noting", vague -ing openers.

After editing all files, run `uv run mkdocs build --strict` from `/Users/paul/Documents/Dev/Personal/adbc-poolhouse` and verify it passes. If it fails because nav references guide files that don't exist yet (those are created in Plan 03), the build failure is expected — only docstring syntax errors are blockers here. In that case, note the nav failure in the summary but confirm docstrings are syntactically valid using `python -c "import ast; ast.parse(open('src/adbc_poolhouse/_duckdb_config.py').read())"` for each modified file.
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "
import ast, pathlib
files = list(pathlib.Path('src/adbc_poolhouse').glob('_*_config.py')) + [pathlib.Path('src/adbc_poolhouse/_base_config.py'), pathlib.Path('src/adbc_poolhouse/_exceptions.py')]
for f in files:
    ast.parse(f.read_text())
    print(f'OK: {f}')
print('All config files parse cleanly')
" && grep -l "Example:" /Users/paul/Documents/Dev/Personal/adbc-poolhouse/src/adbc_poolhouse/_duckdb_config.py /Users/paul/Documents/Dev/Personal/adbc-poolhouse/src/adbc_poolhouse/_snowflake_config.py</automated>
  </verify>
  <done>All config class source files parse without syntax errors; DuckDBConfig and SnowflakeConfig each contain an `Example:` block in their class docstring; all public fields have attribute docstrings</done>
</task>

<task type="auto">
  <name>Task 2: Add exception class docstrings</name>
  <files>src/adbc_poolhouse/_exceptions.py</files>
  <action>
Read `src/adbc_poolhouse/_exceptions.py`. Add docstrings to `PoolhouseError` and `ConfigurationError`:

**PoolhouseError:**
```python
class PoolhouseError(Exception):
    """Base exception for all adbc-poolhouse errors."""
```

**ConfigurationError:**
```python
class ConfigurationError(PoolhouseError, ValueError):
    """Raised when a warehouse config is invalid.

    Inherits from both ``PoolhouseError`` and ``ValueError`` so Pydantic
    wraps it in ``ValidationError`` while preserving ``raises ValueError``
    test expectations.
    """
```

After editing, verify with `python -c "from adbc_poolhouse import PoolhouseError, ConfigurationError; print(PoolhouseError.__doc__); print(ConfigurationError.__doc__)"` run from the project root.
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "from adbc_poolhouse import PoolhouseError, ConfigurationError; assert PoolhouseError.__doc__; assert ConfigurationError.__doc__; print('Exception docstrings OK')"</automated>
  </verify>
  <done>PoolhouseError and ConfigurationError both have docstrings accessible via `__doc__`; `ConfigurationError` documents the dual-inheritance rationale</done>
</task>

</tasks>

<verification>
```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse

# All public classes have docstrings
python -c "
import adbc_poolhouse as m
names = m.__all__
for name in names:
    obj = getattr(m, name)
    if isinstance(obj, type):
        assert obj.__doc__, f'Missing docstring: {name}'
        print(f'OK: {name}')
print('All public classes have docstrings')
"

# DuckDBConfig and SnowflakeConfig have Example blocks
grep -A 3 "Example:" src/adbc_poolhouse/_duckdb_config.py
grep -A 3 "Example:" src/adbc_poolhouse/_snowflake_config.py
```
</verification>

<success_criteria>
- All classes in `__all__` have class-level docstrings
- DuckDBConfig and SnowflakeConfig each have an `Example:` block in the class docstring
- All public field attribute docstrings include `Env: PREFIX_FIELD.` reference
- PoolhouseError and ConfigurationError have docstrings
- All modified source files parse without syntax errors (`python -c "import ast; ast.parse(...)"`)
</success_criteria>

<output>
After completion, create `.planning/phases/07-documentation-and-pypi-publication/07-02-SUMMARY.md`
</output>
