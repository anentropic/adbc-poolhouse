---
phase: 03-config-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/adbc_poolhouse/_base_config.py
  - src/adbc_poolhouse/_duckdb_config.py
autonomous: true
requirements:
  - CFG-01
  - CFG-02
  - CFG-07

must_haves:
  truths:
    - "BaseWarehouseConfig cannot be instantiated directly — raises TypeError"
    - "DuckDBConfig() constructs with default database=':memory:' and pool_size=5"
    - "DuckDBConfig(database=':memory:', pool_size=2) raises pydantic ValidationError"
    - "DuckDBConfig(database='/tmp/test.db', pool_size=5) constructs successfully"
    - "WarehouseConfig Protocol isinstance check returns True for DuckDBConfig instances"
    - "DUCKDB_POOL_SIZE env var populates DuckDBConfig.pool_size (not POOL_SIZE, not unprefixed)"
  artifacts:
    - path: "src/adbc_poolhouse/_base_config.py"
      provides: "BaseWarehouseConfig + WarehouseConfig Protocol"
      exports: ["BaseWarehouseConfig", "WarehouseConfig"]
    - path: "src/adbc_poolhouse/_duckdb_config.py"
      provides: "DuckDBConfig with in-memory pool_size validator"
      exports: ["DuckDBConfig"]
  key_links:
    - from: "src/adbc_poolhouse/_duckdb_config.py"
      to: "src/adbc_poolhouse/_base_config.py"
      via: "class DuckDBConfig(BaseWarehouseConfig)"
      pattern: "class DuckDBConfig.*BaseWarehouseConfig"
    - from: "DuckDBConfig.check_memory_pool_size"
      to: "pydantic.ValidationError"
      via: "model_validator raises ValueError wrapped by pydantic"
      pattern: "@model_validator.*mode.*after"
---

<objective>
Create the foundational config layer: the abstract base class, the WarehouseConfig Protocol, and the DuckDB config model.

Purpose: Everything else in Phase 3 depends on BaseWarehouseConfig. DuckDB is the simplest concrete config and validates the base pattern works end-to-end before building the remaining nine warehouse configs.
Output: _base_config.py (base + protocol), _duckdb_config.py (first concrete config with in-memory validator)
</objective>

<execution_context>
@/Users/paul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/paul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-config-layer/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create _base_config.py with BaseWarehouseConfig and WarehouseConfig Protocol</name>
  <files>src/adbc_poolhouse/_base_config.py</files>
  <action>
Create `src/adbc_poolhouse/_base_config.py` with two public exports:

**WarehouseConfig (Protocol):**
```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class WarehouseConfig(Protocol):
    """Structural type for any adbc-poolhouse warehouse config model.

    Downstream code annotates function parameters as `config: WarehouseConfig`
    to accept any supported warehouse config without importing concrete classes.
    """
    pool_size: int
    max_overflow: int
    timeout: int
    recycle: int
```

**BaseWarehouseConfig (abstract BaseSettings):**
```python
import abc
from pydantic_settings import BaseSettings

class BaseWarehouseConfig(BaseSettings, abc.ABC):
    """Public abstract base for all warehouse config models.

    Provides pool tuning fields with library defaults. Cannot be instantiated
    directly — subclasses must implement _adbc_driver_key().

    Pool tuning fields are inherited by all concrete configs, and each
    concrete config's env_prefix applies to these fields automatically.
    For example, DUCKDB_POOL_SIZE populates DuckDBConfig.pool_size.
    """
    pool_size: int = 5
    max_overflow: int = 3
    timeout: int = 30
    recycle: int = 3600

    @abc.abstractmethod
    def _adbc_driver_key(self) -> str:
        """Internal: returns the ADBC driver name used by the driver manager.

        Not part of the public API (underscore prefix). Implemented by each
        concrete subclass; used in Phase 4 translation layer.
        """
        ...
```

**Critical constraints:**
- Do NOT set `model_config` or `env_prefix` on `BaseWarehouseConfig` — only concrete subclasses define their prefix. If base has an env_prefix, child class prefix resolution breaks.
- Use `abc.ABC` + `@abc.abstractmethod` (not `raise NotImplementedError` in `__init__`). ABC gives proper `TypeError` at class instantiation.
- Imports: `from __future__ import annotations` at top, `from typing import Protocol, runtime_checkable` from stdlib, `from pydantic_settings import BaseSettings`.
- File has no `if TYPE_CHECKING:` block needed for this file.
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "from adbc_poolhouse._base_config import BaseWarehouseConfig, WarehouseConfig; import pydantic; print('ok')"</automated>
    <manual>Verify BaseWarehouseConfig() raises TypeError (cannot instantiate abstract class)</manual>
  </verify>
  <done>_base_config.py exists; `from adbc_poolhouse._base_config import BaseWarehouseConfig, WarehouseConfig` succeeds; `BaseWarehouseConfig()` raises TypeError; WarehouseConfig is a runtime_checkable Protocol with four pool tuning fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create _duckdb_config.py with DuckDBConfig and in-memory pool_size validator</name>
  <files>src/adbc_poolhouse/_duckdb_config.py</files>
  <action>
Create `src/adbc_poolhouse/_duckdb_config.py`:

```python
from __future__ import annotations

from pydantic import model_validator
from pydantic_settings import SettingsConfigDict
from typing_extensions import Self

from adbc_poolhouse._base_config import BaseWarehouseConfig


class DuckDBConfig(BaseWarehouseConfig):
    """DuckDB warehouse configuration.

    Covers all DuckDB ADBC connection parameters. Pool tuning fields
    (pool_size, max_overflow, timeout, recycle) are inherited from
    BaseWarehouseConfig and loaded from DUCKDB_* environment variables.

    Example:
        DuckDBConfig(database='/data/warehouse.db', pool_size=5)
        DuckDBConfig()  # in-memory, pool_size=1 enforced by validator
    """

    model_config = SettingsConfigDict(env_prefix='DUCKDB_')

    database: str = ':memory:'
    """File path or ':memory:'. Env: DUCKDB_DATABASE."""

    read_only: bool = False
    """Open the database in read-only mode. Env: DUCKDB_READ_ONLY."""

    def _adbc_driver_key(self) -> str:
        return 'duckdb'

    @model_validator(mode='after')
    def check_memory_pool_size(self) -> Self:
        if self.database == ':memory:' and self.pool_size > 1:
            raise ValueError(
                'pool_size > 1 with database=":memory:" will give each pool '
                'connection an isolated in-memory database (each connection '
                'sees a different empty DB, so shared state is impossible). '
                'Use pool_size=1 for in-memory DuckDB, or set database to a '
                'file path for shared state across connections.'
            )
        return self
```

**Critical constraints:**
- `Self` must come from `typing_extensions` (stdlib `typing.Self` only available in Python 3.11+, but `typing_extensions` provides it for 3.10+ compat and is already a transitive dep of pydantic).
- `model_config = SettingsConfigDict(env_prefix='DUCKDB_')` — this env_prefix applies to all fields including those inherited from BaseWarehouseConfig. `DUCKDB_POOL_SIZE=10` → `pool_size == 10`. Verified behavior per research.
- The `ValueError` raised in `check_memory_pool_size` is caught by pydantic and wrapped into `ValidationError`. Do NOT catch and re-raise. Callers who want to catch this exception should use `from pydantic import ValidationError`.
- `database` field: use `database` as the field name (more intuitive than the ADBC internal `path` parameter). Phase 4 translator will map `database` → `path` when building ADBC kwargs.
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "
from pydantic import ValidationError
from adbc_poolhouse._duckdb_config import DuckDBConfig
# Default construction
d = DuckDBConfig()
assert d.database == ':memory:'
assert d.pool_size == 5
# File path with pool_size=2 is valid
d2 = DuckDBConfig(database='/tmp/test.db', pool_size=2)
assert d2.pool_size == 2
# in-memory + pool_size=2 raises ValidationError
try:
    DuckDBConfig(database=':memory:', pool_size=2)
    raise AssertionError('should have raised')
except ValidationError:
    pass
# WarehouseConfig Protocol check
from adbc_poolhouse._base_config import WarehouseConfig
assert isinstance(d, WarehouseConfig)
print('all assertions pass')
"</automated>
  </verify>
  <done>DuckDBConfig constructs with defaults; pool_size=2 with :memory: raises ValidationError; file-path database accepts pool_size>1; isinstance(DuckDBConfig(), WarehouseConfig) is True.</done>
</task>

</tasks>

<verification>
Run from project root:
```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse
uv run python -c "
from adbc_poolhouse._base_config import BaseWarehouseConfig, WarehouseConfig
from adbc_poolhouse._duckdb_config import DuckDBConfig
from pydantic import ValidationError
import pytest

# Abstract base cannot be instantiated
try:
    BaseWarehouseConfig()
    print('FAIL: should have raised TypeError')
except TypeError:
    print('PASS: BaseWarehouseConfig is abstract')

# DuckDB basics
d = DuckDBConfig()
assert d.pool_size == 5
assert d.database == ':memory:'
print('PASS: DuckDBConfig defaults correct')

# Validator fires
try:
    DuckDBConfig(database=':memory:', pool_size=2)
    print('FAIL: should have raised ValidationError')
except ValidationError as e:
    print(f'PASS: ValidationError raised: {e.error_count()} error(s)')

print('Plan 01 verification COMPLETE')
"
uv run prek 2>&1 | tail -5
```
</verification>

<success_criteria>
- `_base_config.py` exists with BaseWarehouseConfig (abstract) and WarehouseConfig (Protocol)
- `_duckdb_config.py` exists with DuckDBConfig inheriting BaseWarehouseConfig
- `BaseWarehouseConfig()` raises `TypeError` (abstract)
- `DuckDBConfig(database=':memory:', pool_size=2)` raises `pydantic.ValidationError`
- `DuckDBConfig(database='/tmp/x.db', pool_size=5)` succeeds
- `isinstance(DuckDBConfig(), WarehouseConfig)` is `True`
- `prek` passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/03-config-layer/03-01-SUMMARY.md` with:
- Files created and key exports
- Patterns verified (env_prefix inheritance, abstract base, Protocol isinstance)
- Any deviations from plan
</output>
