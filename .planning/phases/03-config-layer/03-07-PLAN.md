---
phase: 03-config-layer
plan: 07
type: tdd
wave: 4
depends_on:
  - 03-06
files_modified:
  - tests/conftest.py
  - tests/test_configs.py
autonomous: true
requirements:
  - TEST-04

must_haves:
  truths:
    - "All config model unit tests pass (pytest exits 0)"
    - "DuckDB in-memory pool_size validator test uses pytest.raises(ValidationError)"
    - "SnowflakeConfig private key mutual exclusion test passes"
    - "SecretStr masking verified: sensitive values not in repr() output"
    - "env_prefix isolation verified: DUCKDB_POOL_SIZE does not affect SnowflakeConfig"
    - "BaseWarehouseConfig instantiation attempt raises TypeError"
    - "All 11 concrete config classes have at least one construction test"
  artifacts:
    - path: "tests/conftest.py"
      provides: "Shared pytest fixtures for config tests"
      contains: "monkeypatch-based env var helper or parametrized fixtures"
    - path: "tests/test_configs.py"
      provides: "Unit tests for all config models covering TEST-04 requirements"
      min_lines: 100
  key_links:
    - from: "tests/test_configs.py"
      to: "adbc_poolhouse"
      via: "from adbc_poolhouse import ..."
      pattern: "from adbc_poolhouse import"
    - from: "tests/test_configs.py"
      to: "pydantic.ValidationError"
      via: "pytest.raises(ValidationError) for all validator tests"
      pattern: "pytest.raises.*ValidationError"
---

<objective>
Write unit tests for all config models following TDD: write failing tests first, then verify the implementations from Plans 01-06 make them pass.

Purpose: TEST-04 requires unit tests covering field validation, SecretStr handling, env_prefix isolation, and model_validator behaviour for all config models. TDD confirms the implementations are correct and catches any env_prefix or SecretStr edge cases.
Output: tests/conftest.py (shared fixtures), tests/test_configs.py (full unit test suite)
</objective>

<execution_context>
@/Users/paul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/paul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-config-layer/03-RESEARCH.md
</context>

<feature>
  <name>Config model unit tests (TEST-04)</name>
  <files>tests/conftest.py, tests/test_configs.py</files>
  <behavior>
All behaviors testable as `expect(fn(input)).toBe(output)` patterns:

**Field validation (CFG-01, CFG-02):**
- DuckDBConfig() → database=':memory:', pool_size=5, read_only=False
- DuckDBConfig(database=':memory:', pool_size=2) → raises ValidationError containing 'pool_size > 1'
- DuckDBConfig(database='/tmp/x.db', pool_size=2) → constructs, pool_size=2
- DuckDBConfig(database=':memory:', pool_size=1) → constructs, pool_size=1

**SnowflakeConfig validators (CFG-03, CFG-04):**
- SnowflakeConfig(account='org-acc') → constructs
- SnowflakeConfig(account='x', private_key_path=Path('/k'), private_key_pem='PEM') → raises ValidationError containing 'private_key_path'
- SnowflakeConfig(account='x', private_key_path=Path('/k')) → constructs, private_key_pem=None
- SnowflakeConfig(account='x', private_key_pem='PEM') → constructs, private_key_path=None

**SecretStr handling:**
- SnowflakeConfig(account='x', password=SecretStr('secret')) → 'secret' not in repr(config)
- SnowflakeConfig(account='x', password=SecretStr('secret')) → config.password.get_secret_value() == 'secret'

**env_prefix isolation (CFG-07):**
- DUCKDB_POOL_SIZE=8 → DuckDBConfig().pool_size == 8
- DUCKDB_POOL_SIZE=8, SNOWFLAKE_POOL_SIZE=3 → DuckDBConfig().pool_size == 8, SnowflakeConfig(account='x').pool_size == 3
- SNOWFLAKE_POOL_SIZE=3 should NOT affect DuckDBConfig().pool_size (remains 5)

**Abstract base:**
- BaseWarehouseConfig() → raises TypeError

**All concrete configs construct (smoke tests):**
- BigQueryConfig(), PostgreSQLConfig(), FlightSQLConfig() → construct with no errors
- DatabricksConfig(), RedshiftConfig(), TrinoConfig() → construct with no errors
- MSSQLConfig(), TeradataConfig() → construct with no errors

**WarehouseConfig Protocol:**
- isinstance(DuckDBConfig(), WarehouseConfig) → True
- isinstance(SnowflakeConfig(account='x'), WarehouseConfig) → True
  </behavior>
  <implementation>
Follow TDD RED→GREEN→REFACTOR:

**RED phase:**
1. Write all tests in test_configs.py
2. Run `uv run pytest tests/test_configs.py -x` — tests for validators should PASS (implementations exist), but write tests first and confirm they all pass with the completed implementations.

**Implementation structure for test_configs.py:**

```python
"""Unit tests for all adbc_poolhouse config models (TEST-04)."""
import os
from pathlib import Path

import pytest
from pydantic import SecretStr, ValidationError

from adbc_poolhouse import (
    BaseWarehouseConfig,
    BigQueryConfig,
    DatabricksConfig,
    DuckDBConfig,
    FlightSQLConfig,
    MSSQLConfig,
    PostgreSQLConfig,
    RedshiftConfig,
    SnowflakeConfig,
    TeradataConfig,
    TrinoConfig,
    WarehouseConfig,
)


class TestBaseWarehouseConfig:
    def test_cannot_instantiate_directly(self):
        with pytest.raises(TypeError):
            BaseWarehouseConfig()  # type: ignore[abstract]


class TestDuckDBConfig:
    def test_default_construction(self):
        d = DuckDBConfig()
        assert d.database == ':memory:'
        assert d.pool_size == 5
        assert d.max_overflow == 3
        assert d.timeout == 30
        assert d.recycle == 3600
        assert d.read_only is False

    def test_memory_pool_size_validator_fires(self):
        with pytest.raises(ValidationError, match='pool_size > 1'):
            DuckDBConfig(database=':memory:', pool_size=2)

    def test_memory_pool_size_1_is_valid(self):
        d = DuckDBConfig(database=':memory:', pool_size=1)
        assert d.pool_size == 1

    def test_file_database_pool_size_gt1_is_valid(self):
        d = DuckDBConfig(database='/tmp/test.duckdb', pool_size=5)
        assert d.pool_size == 5

    def test_env_prefix_pool_size(self, monkeypatch):
        monkeypatch.setenv('DUCKDB_POOL_SIZE', '8')
        d = DuckDBConfig()
        assert d.pool_size == 8

    def test_env_prefix_isolation(self, monkeypatch):
        monkeypatch.setenv('DUCKDB_POOL_SIZE', '8')
        monkeypatch.setenv('SNOWFLAKE_POOL_SIZE', '3')
        d = DuckDBConfig()
        assert d.pool_size == 8  # SNOWFLAKE_ prefix does not affect DuckDB

    def test_warehouse_config_protocol(self):
        assert isinstance(DuckDBConfig(), WarehouseConfig)


class TestSnowflakeConfig:
    def test_basic_construction(self):
        s = SnowflakeConfig(account='myaccount')
        assert s.account == 'myaccount'
        assert s.pool_size == 5
        assert s.password is None

    def test_private_key_mutual_exclusion(self):
        with pytest.raises(ValidationError, match='private_key_path'):
            SnowflakeConfig(
                account='myaccount',
                private_key_path=Path('/tmp/key.p8'),
                private_key_pem='-----BEGIN PRIVATE KEY-----',
            )

    def test_private_key_path_only_valid(self):
        s = SnowflakeConfig(account='myaccount', private_key_path=Path('/tmp/key.p8'))
        assert s.private_key_path == Path('/tmp/key.p8')
        assert s.private_key_pem is None

    def test_private_key_pem_only_valid(self):
        s = SnowflakeConfig(account='myaccount', private_key_pem=SecretStr('-----BEGIN'))
        assert s.private_key_pem is not None
        assert s.private_key_path is None

    def test_password_is_secret_str(self):
        s = SnowflakeConfig(account='myaccount', password=SecretStr('supersecret'))
        assert 'supersecret' not in repr(s)
        assert s.password is not None
        assert s.password.get_secret_value() == 'supersecret'

    def test_env_prefix_account(self, monkeypatch):
        monkeypatch.setenv('SNOWFLAKE_ACCOUNT', 'envaccount')
        s = SnowflakeConfig()
        assert s.account == 'envaccount'

    def test_env_prefix_pool_size(self, monkeypatch):
        monkeypatch.setenv('SNOWFLAKE_ACCOUNT', 'x')
        monkeypatch.setenv('SNOWFLAKE_POOL_SIZE', '3')
        monkeypatch.setenv('DUCKDB_POOL_SIZE', '10')
        s = SnowflakeConfig()
        assert s.pool_size == 3  # DUCKDB_ prefix does not affect Snowflake

    def test_warehouse_config_protocol(self):
        assert isinstance(SnowflakeConfig(account='x'), WarehouseConfig)


class TestApacheBackendConfigs:
    """Smoke tests for BigQuery, PostgreSQL, FlightSQL."""

    def test_bigquery_default_construction(self):
        bq = BigQueryConfig()
        assert bq.pool_size == 5
        assert isinstance(bq, WarehouseConfig)

    def test_postgresql_default_construction(self):
        pg = PostgreSQLConfig()
        assert pg.pool_size == 5
        assert pg.use_copy is True
        assert isinstance(pg, WarehouseConfig)

    def test_flightsql_default_construction(self):
        f = FlightSQLConfig()
        assert f.pool_size == 5
        assert f.tls_skip_verify is False
        assert isinstance(f, WarehouseConfig)

    def test_env_prefix_isolation_bigquery(self, monkeypatch):
        monkeypatch.setenv('BIGQUERY_POOL_SIZE', '7')
        monkeypatch.setenv('DUCKDB_POOL_SIZE', '2')
        bq = BigQueryConfig()
        assert bq.pool_size == 7


class TestFoundryBackendConfigs:
    """Smoke tests for Databricks, Redshift, Trino, MSSQL, Teradata."""

    def test_databricks_default_construction(self):
        db = DatabricksConfig()
        assert db.pool_size == 5
        assert db.token is None
        assert isinstance(db, WarehouseConfig)

    def test_databricks_token_is_secret_str(self, monkeypatch):
        monkeypatch.setenv('DATABRICKS_TOKEN', 'dapi123')
        db = DatabricksConfig()
        assert isinstance(db.token, SecretStr)
        assert 'dapi123' not in repr(db)

    def test_redshift_default_construction(self):
        rs = RedshiftConfig()
        assert rs.pool_size == 5
        assert isinstance(rs, WarehouseConfig)

    def test_trino_default_construction(self):
        t = TrinoConfig()
        assert t.ssl is True
        assert t.ssl_verify is True
        assert isinstance(t, WarehouseConfig)

    def test_mssql_default_construction(self):
        m = MSSQLConfig()
        assert m.trust_server_certificate is False
        assert isinstance(m, WarehouseConfig)

    def test_teradata_default_construction(self):
        td = TeradataConfig()
        assert td.host is None
        assert isinstance(td, WarehouseConfig)
```

**conftest.py additions:** If tests require shared env-clearing logic or parametrized config factories, add to conftest.py. Minimal additions only — pytest's built-in `monkeypatch` fixture is sufficient for most cases.

**TDD cycle:**
1. Write test_configs.py with all tests above
2. Run `uv run pytest tests/test_configs.py -v` — confirm all pass (implementations exist from Plans 01-06)
3. If any test fails, investigate whether it's a test bug or implementation gap
4. If implementation gap found, fix the implementation in the relevant `_*_config.py` file (not a plan gap closure — fix inline)
  </implementation>
</feature>

<verification>
```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse
# Full test suite including existing tests
uv run pytest tests/ -v 2>&1 | tail -30

# Confirm test count (expect at least 25 tests from test_configs.py + 1 existing)
uv run pytest tests/ --collect-only -q 2>&1 | tail -10

# prek gate
uv run prek 2>&1 | tail -5
```
</verification>

<success_criteria>
- `tests/test_configs.py` exists with tests for all 11 concrete config classes
- `pytest tests/` exits 0 (all tests pass, including existing test_import)
- Tests cover all TEST-04 requirements: field validation, SecretStr handling, env_prefix isolation, model_validator behaviour
- `pytest.raises(ValidationError)` used (not `pytest.raises(ValueError)`) — per RESEARCH.md pitfall #4
- prek passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-config-layer/03-07-SUMMARY.md` with:
- Test count and breakdown by class
- Any implementation fixes made during TDD cycle
- Final pytest output summary
- prek status
</output>
