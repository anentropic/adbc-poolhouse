---
phase: 03-config-layer
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/adbc_poolhouse/_snowflake_config.py
autonomous: true
requirements:
  - CFG-03
  - CFG-04

must_haves:
  truths:
    - "SnowflakeConfig(account='myaccount') constructs successfully"
    - "SnowflakeConfig with both private_key_path and private_key_pem raises ValidationError"
    - "SnowflakeConfig with only private_key_path constructs successfully"
    - "SnowflakeConfig with only private_key_pem constructs successfully"
    - "SnowflakeConfig.password is SecretStr — not exposed in repr()"
    - "SNOWFLAKE_ACCOUNT env var populates SnowflakeConfig.account"
    - "All auth_type values accepted as strings (no enum restriction)"
  artifacts:
    - path: "src/adbc_poolhouse/_snowflake_config.py"
      provides: "SnowflakeConfig with full Snowflake ADBC parameter set and private key mutual exclusion"
      exports: ["SnowflakeConfig"]
  key_links:
    - from: "src/adbc_poolhouse/_snowflake_config.py"
      to: "src/adbc_poolhouse/_base_config.py"
      via: "class SnowflakeConfig(BaseWarehouseConfig)"
      pattern: "class SnowflakeConfig.*BaseWarehouseConfig"
    - from: "SnowflakeConfig.check_private_key_exclusion"
      to: "pydantic.ValidationError"
      via: "model_validator raises ValueError wrapped by pydantic"
      pattern: "@model_validator.*mode.*after"
---

<objective>
Implement SnowflakeConfig covering all Snowflake ADBC authentication methods with a mutual exclusivity validator on private key fields.

Purpose: Snowflake is the most auth-complex backend — JWT, password, OAuth, browser, MFA, Okta, PAT, WIF. Getting CFG-03 and CFG-04 right validates the model_validator pattern for cross-field constraints.
Output: _snowflake_config.py with full Snowflake ADBC parameter set
</objective>

<execution_context>
@/Users/paul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/paul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-config-layer/03-RESEARCH.md
@.planning/phases/03-config-layer/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create _snowflake_config.py with full Snowflake ADBC parameter set</name>
  <files>src/adbc_poolhouse/_snowflake_config.py</files>
  <action>
Create `src/adbc_poolhouse/_snowflake_config.py` with `SnowflakeConfig(BaseWarehouseConfig)`.

**Full field set** (all from RESEARCH.md Snowflake table, all optional except `account`):

```python
from __future__ import annotations

from pathlib import Path

from pydantic import Field, SecretStr, model_validator
from pydantic_settings import SettingsConfigDict
from typing_extensions import Self

from adbc_poolhouse._base_config import BaseWarehouseConfig


class SnowflakeConfig(BaseWarehouseConfig):
    """Snowflake warehouse configuration.

    Supports all authentication methods provided by adbc-driver-snowflake:
    password, JWT (private_key_path / private_key_pem), external browser,
    OAuth, MFA, Okta, PAT, and workload identity federation (WIF).

    Pool tuning fields (pool_size, max_overflow, timeout, recycle) are
    inherited and loaded from SNOWFLAKE_* environment variables.
    """

    model_config = SettingsConfigDict(env_prefix='SNOWFLAKE_')

    # --- Identity ---
    account: str
    """Snowflake account identifier (e.g. 'myorg-myaccount'). Env: SNOWFLAKE_ACCOUNT."""
    user: str | None = None
    """Username. Required for most auth methods. Env: SNOWFLAKE_USER."""

    # --- Password auth ---
    password: SecretStr | None = None
    """Password for basic auth. Env: SNOWFLAKE_PASSWORD."""

    # --- Auth method selector ---
    auth_type: str | None = None
    """Auth method: auth_jwt, auth_ext_browser, auth_oauth, auth_mfa, auth_okta, auth_pat, auth_wif.
    Env: SNOWFLAKE_AUTH_TYPE."""

    # --- JWT / private key auth ---
    private_key_path: Path | None = None
    """File path to a PKCS1 or PKCS8 private key file. Mutually exclusive with private_key_pem.
    Env: SNOWFLAKE_PRIVATE_KEY_PATH."""
    private_key_pem: SecretStr | None = None
    """Inline PEM-encoded PKCS8 private key (encrypted or unencrypted). Mutually exclusive with
    private_key_path. Env: SNOWFLAKE_PRIVATE_KEY_PEM."""
    private_key_passphrase: SecretStr | None = None
    """Passphrase to decrypt an encrypted PKCS8 key. Env: SNOWFLAKE_PRIVATE_KEY_PASSPHRASE."""
    jwt_expire_timeout: str | None = None
    """JWT expiry duration (e.g. '300ms', '1m30s'). Env: SNOWFLAKE_JWT_EXPIRE_TIMEOUT."""

    # --- OAuth ---
    oauth_token: SecretStr | None = None
    """Bearer token for auth_oauth. Env: SNOWFLAKE_OAUTH_TOKEN."""

    # --- Okta ---
    okta_url: str | None = None
    """Okta server URL required for auth_okta. Env: SNOWFLAKE_OKTA_URL."""

    # --- WIF ---
    identity_provider: str | None = None
    """Identity provider for auth_wif. Env: SNOWFLAKE_IDENTITY_PROVIDER."""

    # --- Session / scope ---
    database: str | None = None
    """Default database. Env: SNOWFLAKE_DATABASE."""
    schema_: str | None = Field(default=None, validation_alias='schema', alias='schema')
    """Default schema. Python attribute is schema_ to avoid Pydantic conflicts;
    env var is SNOWFLAKE_SCHEMA. Env: SNOWFLAKE_SCHEMA."""
    warehouse: str | None = None
    """Snowflake virtual warehouse. Env: SNOWFLAKE_WAREHOUSE."""
    role: str | None = None
    """Snowflake role. Env: SNOWFLAKE_ROLE."""
    region: str | None = None
    """Snowflake region (if not embedded in account). Env: SNOWFLAKE_REGION."""

    # --- Connection ---
    host: str | None = None
    """Explicit hostname (alternative to account-derived URI). Env: SNOWFLAKE_HOST."""
    port: int | None = None
    """Connection port. Env: SNOWFLAKE_PORT."""
    protocol: str | None = None
    """Protocol: 'http' or 'https'. Env: SNOWFLAKE_PROTOCOL."""

    # --- Timeouts ---
    login_timeout: str | None = None
    """Login retry timeout duration string. Env: SNOWFLAKE_LOGIN_TIMEOUT."""
    request_timeout: str | None = None
    """Request retry timeout duration string. Env: SNOWFLAKE_REQUEST_TIMEOUT."""
    client_timeout: str | None = None
    """Network roundtrip timeout duration string. Env: SNOWFLAKE_CLIENT_TIMEOUT."""

    # --- Security ---
    tls_skip_verify: bool = False
    """Disable TLS certificate verification. Env: SNOWFLAKE_TLS_SKIP_VERIFY."""
    ocsp_fail_open_mode: bool = True
    """OCSP fail-open mode (True = allow connection on OCSP errors). Env: SNOWFLAKE_OCSP_FAIL_OPEN_MODE."""

    # --- Session behaviour ---
    keep_session_alive: bool = False
    """Prevent session expiry during long operations. Env: SNOWFLAKE_KEEP_SESSION_ALIVE."""

    # --- Telemetry / misc ---
    app_name: str | None = None
    """Application identifier sent to Snowflake. Env: SNOWFLAKE_APP_NAME."""
    disable_telemetry: bool = False
    """Disable Snowflake usage telemetry. Env: SNOWFLAKE_DISABLE_TELEMETRY."""
    cache_mfa_token: bool = False
    """Cache MFA token for subsequent connections. Env: SNOWFLAKE_CACHE_MFA_TOKEN."""
    store_temp_creds: bool = False
    """Cache ID token for SSO. Env: SNOWFLAKE_STORE_TEMP_CREDS."""

    def _adbc_driver_key(self) -> str:
        return 'snowflake'

    @model_validator(mode='after')
    def check_private_key_exclusion(self) -> Self:
        if self.private_key_path is not None and self.private_key_pem is not None:
            raise ValueError(
                'Provide only one of private_key_path (path to a PKCS1/PKCS8 '
                'private key file) or private_key_pem (inline PEM-encoded key '
                'content), not both. Use private_key_path for a key file, or '
                'private_key_pem for inline PEM content.'
            )
        return self
```

**Critical constraints:**
- `schema_` field: use `Field(validation_alias='schema', alias='schema')` so the env var `SNOWFLAKE_SCHEMA` (without trailing underscore) populates the field. The Python attribute is `schema_` to avoid Pydantic's own `schema` method name. Verify during implementation by checking that `os.environ['SNOWFLAKE_SCHEMA'] = 'PUBLIC'` → `config.schema_ == 'PUBLIC'`. If the alias approach causes issues with pydantic-settings env loading, fall back to `Field(default=None, alias='schema')` without validation_alias and test.
- `private_key_path` uses `Path` type (not `str`) — OS-portable, validated path object.
- All SecretStr fields: `password`, `private_key_pem`, `private_key_passphrase`, `oauth_token`, `auth_credentials` (BigQuery only — not here).
- Do NOT use `extra='forbid'` — leave default `extra='ignore'`.
- Let `ValidationError` from `check_private_key_exclusion` bubble through naturally — do not catch.
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && uv run python -c "
from pathlib import Path
from pydantic import ValidationError
from adbc_poolhouse._snowflake_config import SnowflakeConfig

# Basic construction
s = SnowflakeConfig(account='myaccount')
assert s.account == 'myaccount'
assert s.password is None
print('PASS: basic construction')

# SecretStr masking
import os
os.environ['SNOWFLAKE_ACCOUNT'] = 'testaccount'
os.environ['SNOWFLAKE_PASSWORD'] = 'supersecret'
s2 = SnowflakeConfig()
assert 'supersecret' not in repr(s2)
assert s2.password.get_secret_value() == 'supersecret'
del os.environ['SNOWFLAKE_ACCOUNT']
del os.environ['SNOWFLAKE_PASSWORD']
print('PASS: SecretStr masking')

# Mutual exclusion fires
try:
    SnowflakeConfig(
        account='myaccount',
        private_key_path=Path('/tmp/key.p8'),
        private_key_pem='-----BEGIN PRIVATE KEY-----',
    )
    raise AssertionError('should have raised ValidationError')
except ValidationError:
    print('PASS: mutual exclusion validator fires')

# Single private_key_path is fine
s3 = SnowflakeConfig(account='myaccount', private_key_path=Path('/tmp/key.p8'))
assert s3.private_key_path == Path('/tmp/key.p8')
print('PASS: single private_key_path accepted')

print('All SnowflakeConfig assertions pass')
"</automated>
  </verify>
  <done>SnowflakeConfig constructs with account-only; password is SecretStr (masked in repr); private_key_path + private_key_pem simultaneously raises ValidationError; each field alone succeeds; SNOWFLAKE_* env vars populate correct fields.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse
uv run python -c "
from adbc_poolhouse._snowflake_config import SnowflakeConfig
from adbc_poolhouse._base_config import WarehouseConfig
from pydantic import ValidationError
from pathlib import Path

s = SnowflakeConfig(account='org-acct')
assert isinstance(s, WarehouseConfig), 'Protocol check failed'
assert s.pool_size == 5
assert s.tls_skip_verify is False
assert s.ocsp_fail_open_mode is True
print('PASS: SnowflakeConfig complete')
"
uv run prek 2>&1 | tail -5
```
</verification>

<success_criteria>
- `_snowflake_config.py` exists with all Snowflake ADBC fields from RESEARCH.md
- `SnowflakeConfig(account='x')` succeeds
- Both private_key fields simultaneously raises ValidationError with descriptive message
- `password` field is SecretStr — not visible in repr
- `isinstance(SnowflakeConfig(account='x'), WarehouseConfig)` is True
- prek passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-config-layer/03-02-SUMMARY.md` with:
- Files created and fields implemented
- schema_ field naming resolution (what alias approach worked)
- Any auth_type or field deviations from RESEARCH.md
</output>
