---
phase: 04-translation-and-driver-detection
plan: "04"
type: tdd
wave: 3
depends_on:
  - "04-03"
files_modified:
  - tests/test_translators.py
autonomous: true
requirements:
  - TEST-05

must_haves:
  truths:
    - "pytest tests/test_translators.py passes with zero failures"
    - "Every translator function is tested with at least 2 input variants"
    - "Each test asserts the exact dict[str, str] output (not just subset membership)"
    - "Tests run without any ADBC warehouse driver installed — no live driver connection"
    - "Snowflake tests cover: account-only config, user+password config, schema_ attribute mapping, bool flags as 'true'/'false' strings"
  artifacts:
    - path: "tests/test_translators.py"
      provides: "Translator unit tests for all 10 warehouse backends"
      min_lines: 100
      contains: "class TestDuckDBTranslator"
  key_links:
    - from: "tests/test_translators.py"
      to: "adbc_poolhouse._duckdb_translator.translate_duckdb"
      via: "direct import, no mock needed"
      pattern: "from adbc_poolhouse\\._duckdb_translator import translate_duckdb"
    - from: "tests/test_translators.py"
      to: "adbc_poolhouse._translators.translate_config"
      via: "coordinator dispatch test"
      pattern: "from adbc_poolhouse\\._translators import translate_config"
---

<objective>
TDD unit tests for all 10 parameter translator functions (TEST-05). Tests assert exact `dict[str, str]` output for given config inputs — pure input/output verification with no mocking needed (translators are pure functions with no side effects).

Purpose: TDD design benefit — defining expected key strings before writing translators would have caught ADBC key naming errors early. For Phase 4, the tests serve as regression guards and documentation of the exact ADBC key mapping contract.

Output: `tests/test_translators.py` with test classes for all 10 translators plus coordinator dispatch.
</objective>

<execution_context>
@/Users/paul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/paul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-translation-and-driver-detection/04-RESEARCH.md
@.planning/phases/04-translation-and-driver-detection/04-03-SUMMARY.md
@tests/conftest.py
</context>

<feature>
  <name>Translator unit tests (TEST-05)</name>
  <files>tests/test_translators.py</files>
  <behavior>
Given a config instance, each translator returns the exact expected dict[str, str].

Test cases per warehouse:

**DuckDB (TestDuckDBTranslator):**
- DuckDBConfig() → {"path": ":memory:"}
- DuckDBConfig(database="/tmp/test.db") → {"path": "/tmp/test.db"}
- DuckDBConfig(database="/tmp/test.db", read_only=True) → {"path": "/tmp/test.db", "access_mode": "READ_ONLY"}

**Snowflake (TestSnowflakeTranslator):**
- SnowflakeConfig(account="myorg-myaccount") → dict containing {"adbc.snowflake.sql.account": "myorg-myaccount"}, no "username" key (user not set)
- SnowflakeConfig(account="a", user="bob", password=SecretStr("s3cr3t")) → dict containing {"username": "bob", "password": "s3cr3t"}
- SnowflakeConfig(account="a", schema_="PUBLIC") → dict containing {"adbc.snowflake.sql.schema": "PUBLIC"} (schema_ attribute → ADBC key without underscore)
- SnowflakeConfig(account="a") → tls_skip_verify = "false", ocsp_fail_open_mode = "true" (string booleans per defaults)
- SnowflakeConfig with private_key_path set → {"adbc.snowflake.sql.client_option.jwt_private_key": str(path)}

**BigQuery (TestBigQueryTranslator):**
- BigQueryConfig() → {} (all optional, empty config)
- BigQueryConfig(project_id="my-proj") → {"adbc.bigquery.sql.project_id": "my-proj"}
- BigQueryConfig(auth_type="SERVICE_ACCOUNT") → {"adbc.bigquery.sql.auth_type": "SERVICE_ACCOUNT"}

**PostgreSQL (TestPostgreSQLTranslator):**
- PostgreSQLConfig() → {} (uri is None)
- PostgreSQLConfig(uri="postgresql://localhost/mydb") → {"uri": "postgresql://localhost/mydb"}
- (Document in test that use_copy is intentionally absent from translator output)

**FlightSQL (TestFlightSQLTranslator):**
- FlightSQLConfig() → {} or dict with only non-None defaults (verify against actual config defaults)
- FlightSQLConfig(uri="grpc://localhost:32010") → dict containing {"uri": "grpc://localhost:32010"}
- FlightSQLConfig(tls_skip_verify=True) → dict containing {"adbc.flight.sql.client_option.tls_skip_verify": "true"}

**Databricks (TestDatabricksTranslator):**
- DatabricksConfig() → {} (uri is None)
- DatabricksConfig(uri=SecretStr("databricks://host/catalog")) → {"uri": "databricks://host/catalog"} (SecretStr extracted)

**Redshift (TestRedshiftTranslator):**
- RedshiftConfig() → {}
- RedshiftConfig(uri="redshift://host:5439/mydb") → {"uri": "redshift://host:5439/mydb"}

**Trino (TestTrinoTranslator):**
- TrinoConfig() → check actual TrinoConfig fields and test meaningful variants

**MSSQL (TestMSSQLTranslator):**
- MSSQLConfig() → {} or dict with non-None defaults (verify against config)
- MSSQLConfig with uri set (if uri field exists on MSSQLConfig) → {"uri": "..."}

**Teradata (TestTeradataTranslator):**
- TeradataConfig() → whatever the actual translator returns for empty config
- Add comment: "# LOW confidence — TeradataConfig fields triangulated from non-authoritative sources"

**Coordinator (TestTranslateConfig):**
- translate_config(DuckDBConfig()) == translate_duckdb(DuckDBConfig())
- translate_config(SnowflakeConfig(account="a")) == translate_snowflake(SnowflakeConfig(account="a"))
- translate_config("not a config") raises TypeError with "Unsupported config type" in message
  </behavior>
  <implementation>
Follow RED→GREEN→REFACTOR:

**RED:** Write all test classes in test_translators.py. Run `pytest tests/test_translators.py -x` — tests MUST fail (functions may not exist yet or may have wrong output). Commit: `test(04-04): add failing translator unit tests`

**GREEN:** All translator functions already exist from plans 04-01 and 04-02. Run tests. If any fail, fix the translator implementation (not the test expectation) until all pass. Commit: `feat(04-04): all translator tests pass`

**REFACTOR (if needed):** Extract common fixtures for SecretStr values that trigger detect-secrets (use `# pragma: allowlist secret` on variable assignment lines that hold credential-like strings). Commit: `refactor(04-04): clean up translator tests`

Test file structure:
```python
from __future__ import annotations

import pytest
from pydantic import SecretStr

from adbc_poolhouse._bigquery_config import BigQueryConfig
from adbc_poolhouse._bigquery_translator import translate_bigquery
from adbc_poolhouse._databricks_config import DatabricksConfig
from adbc_poolhouse._databricks_translator import translate_databricks
# ... all other imports ...
from adbc_poolhouse._translators import translate_config


class TestDuckDBTranslator:
    def test_memory_database(self) -> None:
        ...

    def test_file_database(self) -> None:
        ...

    def test_read_only(self) -> None:
        ...


class TestSnowflakeTranslator:
    ...
# etc.
```

Each test method has a descriptive name and single assertion (or tightly related assertions). Use `pytest.MonkeyPatch` annotation if monkeypatching (basedpyright requires explicit type annotation — see Phase 3 pattern). Apply `# pragma: allowlist secret` to any variable holding password/key strings.
  </implementation>
</feature>

<verification>
```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && pytest tests/test_translators.py -v 2>&1 | tail -40
```

All tests must pass. prek must pass:

```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && prek run --all-files 2>&1 | tail -20
```
</verification>

<success_criteria>
- pytest tests/test_translators.py passes with 0 failures
- At minimum: DuckDB (3 tests), Snowflake (5 tests), BigQuery (3 tests), PostgreSQL (2 tests), FlightSQL (3 tests), each Foundry backend (2 tests each), coordinator dispatch (3 tests)
- No test imports any ADBC warehouse driver package directly — tests only import config classes and translator functions
- prek passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/04-translation-and-driver-detection/04-04-SUMMARY.md`
</output>
