---
phase: 04-translation-and-driver-detection
plan: "03"
type: execute
wave: 2
depends_on:
  - "04-01"
  - "04-02"
files_modified:
  - src/adbc_poolhouse/_translators.py
  - src/adbc_poolhouse/_drivers.py
  - src/adbc_poolhouse/_driver_api.py
  - src/adbc_poolhouse/_pool_types.py
autonomous: true
requirements:
  - DRIV-01
  - DRIV-02
  - DRIV-03
  - DRIV-04
  - TYPE-01
  - TYPE-02

must_haves:
  truths:
    - "translate_config(DuckDBConfig()) returns {'path': ':memory:'} — coordinator dispatches to correct per-warehouse function"
    - "translate_config raises TypeError for unsupported config type — no silent fallthrough"
    - "resolve_driver(DuckDBConfig()) uses find_spec('_duckdb'), returns path string ending in _duckdb*.so"
    - "resolve_driver raises ImportError with 'pip install adbc-poolhouse[duckdb]' when _duckdb not found"
    - "Foundry configs (DatabricksConfig etc.) skip find_spec and go straight to manifest path"
    - "create_adbc_connection catches adbc_driver_manager NOT_FOUND and re-raises as ImportError with https://docs.adbc-drivers.org/ in the message (DRIV-03 Foundry case)"
    - "import adbc_poolhouse succeeds in environment with only pydantic-settings installed — no ADBC driver required"
    - "All cast() and # type: ignore suppressions are in _driver_api.py and _pool_types.py only"
  artifacts:
    - path: "src/adbc_poolhouse/_translators.py"
      provides: "translate_config() dispatch function"
      exports: ["translate_config"]
    - path: "src/adbc_poolhouse/_drivers.py"
      provides: "resolve_driver() 3-path detection function"
      exports: ["resolve_driver"]
    - path: "src/adbc_poolhouse/_driver_api.py"
      provides: "create_adbc_connection() ADBC facade with NOT_FOUND reraise"
      exports: ["create_adbc_connection"]
    - path: "src/adbc_poolhouse/_pool_types.py"
      provides: "AdbcCreatorFn type alias for Phase 5"
      exports: ["AdbcCreatorFn"]
  key_links:
    - from: "_translators.py translate_config"
      to: "each per-warehouse translator"
      via: "isinstance dispatch"
      pattern: "isinstance\\(config, \\w+Config\\)"
    - from: "_drivers.py resolve_driver"
      to: "importlib.util.find_spec"
      via: "lazy call inside function body"
      pattern: "importlib\\.util\\.find_spec"
    - from: "_driver_api.py create_adbc_connection"
      to: "adbc_driver_manager.dbapi.connect"
      via: "direct call with type ignore"
      pattern: "adbc_driver_manager\\.dbapi\\.connect"
    - from: "_driver_api.py except block"
      to: "ImportError with docs.adbc-drivers.org"
      via: "catch adbc_driver_manager NOT_FOUND, reraise as ImportError"
      pattern: "docs\\.adbc-drivers\\.org"
---

<objective>
Wire the Phase 4 infrastructure: (1) `_translators.py` dispatch coordinator, (2) `_drivers.py` 3-path driver detection, (3) `_driver_api.py` ADBC facade with all type suppressions and Foundry NOT_FOUND reraise, (4) minimal `_pool_types.py` type alias scaffold.

Purpose: This is the integration point where all 10 per-warehouse translator modules and the driver resolution logic come together. Phase 5 will call `translate_config()` and `resolve_driver()` to assemble `create_pool()`.

Output: Four wiring modules that complete the Phase 4 layer.
</objective>

<execution_context>
@/Users/paul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/paul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-translation-and-driver-detection/04-RESEARCH.md
@.planning/phases/04-translation-and-driver-detection/04-01-SUMMARY.md
@.planning/phases/04-translation-and-driver-detection/04-02-SUMMARY.md
@src/adbc_poolhouse/_base_config.py
@src/adbc_poolhouse/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Translator coordinator (_translators.py)</name>
  <files>
    src/adbc_poolhouse/_translators.py
  </files>
  <action>
Create `src/adbc_poolhouse/_translators.py` — the dispatch coordinator. This module imports all 10 per-warehouse translator functions and exposes a single `translate_config()` function.

```python
from __future__ import annotations

from adbc_poolhouse._base_config import WarehouseConfig
from adbc_poolhouse._bigquery_config import BigQueryConfig
from adbc_poolhouse._bigquery_translator import translate_bigquery
from adbc_poolhouse._databricks_config import DatabricksConfig
from adbc_poolhouse._databricks_translator import translate_databricks
from adbc_poolhouse._duckdb_config import DuckDBConfig
from adbc_poolhouse._duckdb_translator import translate_duckdb
from adbc_poolhouse._flightsql_config import FlightSQLConfig
from adbc_poolhouse._flightsql_translator import translate_flightsql
from adbc_poolhouse._mssql_config import MSSQLConfig
from adbc_poolhouse._mssql_translator import translate_mssql
from adbc_poolhouse._postgresql_config import PostgreSQLConfig
from adbc_poolhouse._postgresql_translator import translate_postgresql
from adbc_poolhouse._redshift_config import RedshiftConfig
from adbc_poolhouse._redshift_translator import translate_redshift
from adbc_poolhouse._snowflake_config import SnowflakeConfig
from adbc_poolhouse._snowflake_translator import translate_snowflake
from adbc_poolhouse._teradata_config import TeradataConfig
from adbc_poolhouse._teradata_translator import translate_teradata
from adbc_poolhouse._trino_config import TrinoConfig
from adbc_poolhouse._trino_translator import translate_trino


def translate_config(config: WarehouseConfig) -> dict[str, str]:
    """Translate any supported warehouse config to ADBC driver kwargs.

    Returns:
        A dict[str, str] of kwargs to pass as db_kwargs to
        adbc_driver_manager.dbapi.connect(). All values are strings.

    Raises:
        TypeError: If config is not a recognised WarehouseConfig subclass.
    """
    if isinstance(config, DuckDBConfig):
        return translate_duckdb(config)
    if isinstance(config, SnowflakeConfig):
        return translate_snowflake(config)
    if isinstance(config, BigQueryConfig):
        return translate_bigquery(config)
    if isinstance(config, PostgreSQLConfig):
        return translate_postgresql(config)
    if isinstance(config, FlightSQLConfig):
        return translate_flightsql(config)
    if isinstance(config, DatabricksConfig):
        return translate_databricks(config)
    if isinstance(config, RedshiftConfig):
        return translate_redshift(config)
    if isinstance(config, TrinoConfig):
        return translate_trino(config)
    if isinstance(config, MSSQLConfig):
        return translate_mssql(config)
    if isinstance(config, TeradataConfig):
        return translate_teradata(config)
    raise TypeError(f"Unsupported config type: {type(config).__name__}")
```

This module is internal only — do NOT add to `__init__.py` exports.

Note: isinstance checks must be ordered with most-specific types first if any inheritance exists. Check Phase 3 config class hierarchy. If all concrete configs are siblings (all inherit directly from BaseWarehouseConfig), order does not matter; use alphabetical.
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "
from adbc_poolhouse._translators import translate_config
from adbc_poolhouse._duckdb_config import DuckDBConfig
from adbc_poolhouse._snowflake_config import SnowflakeConfig

# DuckDB dispatch
r1 = translate_config(DuckDBConfig())
assert r1 == {'path': ':memory:'}, f'DuckDB dispatch: {r1}'

# TypeError for unknown type
try:
    translate_config('not a config')  # type: ignore[arg-type]
    assert False, 'Should have raised TypeError'
except TypeError as e:
    assert 'Unsupported config type' in str(e), f'TypeError message: {e}'

print('OK')
"</automated>
  </verify>
  <done>
    - translate_config dispatches to the correct per-warehouse function for all 10 config types
    - translate_config raises TypeError with "Unsupported config type: {name}" for unknown types
    - _translators.py is NOT exported in __init__.py
  </done>
</task>

<task type="auto">
  <name>Task 2: Driver detection (_drivers.py), ADBC facade (_driver_api.py), and type scaffold (_pool_types.py)</name>
  <files>
    src/adbc_poolhouse/_drivers.py
    src/adbc_poolhouse/_driver_api.py
    src/adbc_poolhouse/_pool_types.py
  </files>
  <action>
**Create `src/adbc_poolhouse/_drivers.py`:**

Implements `resolve_driver(config: WarehouseConfig) -> str` using 3-path logic. All imports at module level are config classes only (safe — config modules have no ADBC imports). ADBC driver imports are strictly inside function bodies (DRIV-04).

Key implementation rules:
- DuckDB: use `importlib.util.find_spec("_duckdb")` (C extension), NOT `find_spec("duckdb")`. Return `spec.origin` as string. See RESEARCH.md Pitfall 1 and 7.
- PyPI drivers (Snowflake, BigQuery, PostgreSQL, FlightSQL): use `find_spec(pkg_name)` then `import pkg; return pkg._driver_path()`. If find_spec returns None, pass the package name back to let adbc_driver_manager attempt manifest resolution (Path 2). If adbc_driver_manager also fails, raise ImportError with install command (Path 3 — raised from _driver_api.py).
- Foundry drivers (Databricks, Redshift, Trino, MSSQL, Teradata): skip find_spec entirely. Return the short driver name string directly (e.g., `"databricks"`). The adbc_driver_manager will search manifests. See RESEARCH.md Pitfall 2 and Pattern 3.

The `ImportError` for PyPI packages when Path 1 fails: implement by returning the package name (Path 2 fallback) — the actual ImportError is raised by `create_adbc_connection()` in `_driver_api.py` when adbc_driver_manager cannot find the manifest. Include the install command in the error message there.

However, for DuckDB specifically: DuckDB has no manifest fallback (it's PyPI-only). If `find_spec("_duckdb")` returns None, raise `ImportError` immediately in `resolve_driver()` with message: `"DuckDB ADBC driver not found. Run: \`pip install adbc-poolhouse[duckdb]\`"`

Use a module-level dict mapping config types to their package and extra names for PyPI drivers:

```python
# (package_name, pip_extra_name)
_PYPI_PACKAGES: dict[type, tuple[str, str]] = {
    SnowflakeConfig: ("adbc_driver_snowflake", "snowflake"),
    BigQueryConfig: ("adbc_driver_bigquery", "bigquery"),
    PostgreSQLConfig: ("adbc_driver_postgresql", "postgresql"),
    FlightSQLConfig: ("adbc_driver_flightsql", "flightsql"),
}

# (driver_manager_name, dbc_install_name)  — for ImportError message construction
_FOUNDRY_DRIVERS: dict[type, tuple[str, str]] = {
    DatabricksConfig: ("databricks", "databricks"),
    RedshiftConfig: ("redshift", "redshift"),
    TrinoConfig: ("trino", "trino"),
    MSSQLConfig: ("mssql", "mssql"),
    TeradataConfig: ("teradata", "teradata"),  # LOW confidence name
}
```

The dispatch in `resolve_driver()` should:
1. Check if config type is DuckDBConfig → call `_resolve_duckdb()`
2. Check if config type is in `_PYPI_PACKAGES` → call `_resolve_pypi_driver(config_class_name, pkg_name, extra)`
3. Check if config type is in `_FOUNDRY_DRIVERS` → return the short driver name string
4. Raise TypeError for unknown config types

`_resolve_pypi_driver(config_class_name, pkg_name, extra)` implementation:
- Path 1: `spec = find_spec(pkg_name)` → if not None, do `pkg = __import__(pkg_name); return pkg._driver_path()` with `# type: ignore[attr-defined]`
- If find_spec returns None: return `pkg_name` (let _driver_api.py handle Path 2/3 error)

**Create `src/adbc_poolhouse/_driver_api.py`:**

`create_adbc_connection()` must catch the adbc_driver_manager NOT_FOUND exception when a Foundry driver manifest is absent and re-raise it as a user-friendly `ImportError` pointing to https://docs.adbc-drivers.org/ (DRIV-03 locked decision). The `_FOUNDRY_DRIVERS` dict from `_drivers.py` is needed to build the error message; import it at the top of `_driver_api.py` alongside the adbc_driver_manager import.

```python
from __future__ import annotations

from typing import TYPE_CHECKING

import adbc_driver_manager
import adbc_driver_manager.dbapi  # runtime import — adbc-driver-manager is a runtime dep

from adbc_poolhouse._drivers import _FOUNDRY_DRIVERS

if TYPE_CHECKING:
    from adbc_driver_manager.dbapi import Connection


def create_adbc_connection(
    driver_path: str,
    kwargs: dict[str, str],
    *,
    entrypoint: str | None = None,
) -> "Connection":
    """Create an ADBC DBAPI connection.

    All cast() and # type: ignore suppressions for the ADBC driver manager
    are concentrated in this module.

    For Foundry drivers (Databricks, Redshift, Trino, MSSQL, Teradata):
    if the driver manifest is not found, adbc_driver_manager raises
    AdbcStatusCode.NOT_FOUND. This is caught here and re-raised as
    ImportError with a human-readable message pointing to
    https://docs.adbc-drivers.org/ (DRIV-03).

    All other ADBC exceptions (auth failures, network errors, etc.)
    pass through raw — wrapping is a Phase 5+ concern.

    Args:
        driver_path: Path to the driver shared library, or a short driver
            name for manifest-based resolution (Foundry drivers).
        kwargs: ADBC db_kwargs as dict[str, str] from translate_config().
        entrypoint: Optional ADBC entry point symbol. Required for DuckDB
            (entrypoint='duckdb_adbc_init').
    """
    connect_kwargs: dict[str, object] = {"db_kwargs": kwargs}
    if entrypoint is not None:
        connect_kwargs["entrypoint"] = entrypoint

    # Map short driver name -> dbc_install_name for Foundry error messages.
    # Build a reverse lookup from driver_path (short name) to install name.
    _foundry_name_to_install = {v[0]: v[1] for v in _FOUNDRY_DRIVERS.values()}

    try:
        conn = adbc_driver_manager.dbapi.connect(  # type: ignore[call-overload]
            driver_path,
            **connect_kwargs,
        )
    except adbc_driver_manager.AdbcStatusCode as exc:  # type: ignore[attr-defined]
        # AdbcStatusCode is the base for all adbc_driver_manager status errors.
        # Check if the error indicates a missing driver (NOT_FOUND).
        if "NOT_FOUND" in str(exc) or "not found" in str(exc).lower():
            install_name = _foundry_name_to_install.get(driver_path, driver_path)
            raise ImportError(
                f"ADBC driver '{driver_path}' not found. "
                f"Install it with: dbc install {install_name}\n"
                f"See: https://docs.adbc-drivers.org/"
            ) from exc
        raise  # re-raise other adbc_driver_manager status errors raw
    except Exception as exc:  # noqa: BLE001
        # adbc_driver_manager may raise ProgrammingError or other exceptions
        # for missing drivers depending on version. Check error message.
        exc_str = str(exc)
        if (
            "NOT_FOUND" in exc_str
            or "Driver not found" in exc_str
            or "No driver" in exc_str
        ) and driver_path in _foundry_name_to_install:
            install_name = _foundry_name_to_install[driver_path]
            raise ImportError(
                f"ADBC driver '{driver_path}' not found. "
                f"Install it with: dbc install {install_name}\n"
                f"See: https://docs.adbc-drivers.org/"
            ) from exc
        raise

    return conn  # type: ignore[return-value]
```

**IMPLEMENTATION NOTE:** The exact exception type raised by `adbc_driver_manager` when a manifest is not found varies by version. At implementation time, inspect the actual exception type by running:
```python
import adbc_driver_manager
print(dir(adbc_driver_manager))  # look for AdbcStatusCode, AdbcException, DatabaseError, etc.
```
Then use the correct exception class(es) in the `except` clauses. The two-layer `except` (AdbcStatusCode + generic Exception) above is a safe fallback pattern — adapt to the actual API. The key requirement (DRIV-03) is: when a Foundry manifest is missing, raise `ImportError` with the docs URL. The exact exception class is an implementation detail.

Note: `adbc_driver_manager` is a runtime dependency (always installed), so the top-level import here is intentional and correct. Only `adbc_driver_snowflake`, `adbc_driver_duckdb`, etc. (the warehouse-specific drivers) must be lazy. The driver manager itself is always available.

**Create `src/adbc_poolhouse/_pool_types.py`:**

```python
from __future__ import annotations

from typing import TYPE_CHECKING, Callable

if TYPE_CHECKING:
    from adbc_driver_manager.dbapi import Connection


# Type alias for the callable that QueuePool.creator expects.
# QueuePool requires Callable[[], DBAPIConnection] but ADBC's Connection
# type does not satisfy SQLAlchemy's internal _DBAPIConnection Protocol
# without a cast(). Phase 5 uses this alias as the cast target.
AdbcCreatorFn = Callable[[], "Connection"]
```

This is the minimal Phase 4 scope for `_pool_types.py` per CONTEXT.md discretion. QueuePool assembly is Phase 5. Only the type alias is needed now.
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "
import importlib.util

# Verify _drivers.py importable (only config imports at module level)
from adbc_poolhouse._drivers import resolve_driver
from adbc_poolhouse._driver_api import create_adbc_connection
from adbc_poolhouse._pool_types import AdbcCreatorFn
from adbc_poolhouse._translators import translate_config

# Verify _drivers.py is importable — no ADBC warehouse driver imports at module level
print('_drivers.py importable OK')

# Verify _pool_types.py has AdbcCreatorFn type alias
from adbc_poolhouse import _pool_types
assert hasattr(_pool_types, 'AdbcCreatorFn'), 'AdbcCreatorFn missing from _pool_types'
print('_pool_types.py OK')

# Verify resolve_driver raises ImportError for DuckDB when _duckdb not found
from unittest.mock import patch
from adbc_poolhouse._duckdb_config import DuckDBConfig
with patch('importlib.util.find_spec', return_value=None):
    try:
        resolve_driver(DuckDBConfig())
        print('ERROR: should have raised ImportError')
    except ImportError as e:
        assert 'pip install adbc-poolhouse[duckdb]' in str(e), f'Wrong message: {e}'
        print('DuckDB ImportError raised correctly')

# Verify _driver_api.py contains NOT_FOUND catch-and-reraise logic
import inspect
from adbc_poolhouse import _driver_api
src = inspect.getsource(_driver_api)
assert 'docs.adbc-drivers.org' in src, '_driver_api.py missing docs.adbc-drivers.org URL'
assert 'ImportError' in src, '_driver_api.py missing ImportError reraise'
assert 'NOT_FOUND' in src, '_driver_api.py missing NOT_FOUND check'
print('_driver_api.py NOT_FOUND reraise logic present OK')

print('All checks OK')
" && cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "
# Verify import adbc_poolhouse works without ADBC warehouse drivers
import adbc_poolhouse
print('adbc_poolhouse importable OK')
"</automated>
    <manual>Check _drivers.py has no top-level warehouse driver imports (grep for adbc_driver_snowflake, adbc_driver_duckdb, etc. at module level). Check _driver_api.py has all type: ignore comments concentrated in it and contains the https://docs.adbc-drivers.org/ URL in its ImportError message.</manual>
  </verify>
  <done>
    - _translators.py, _drivers.py, _driver_api.py, _pool_types.py all importable
    - resolve_driver raises ImportError with "pip install adbc-poolhouse[duckdb]" for DuckDB when _duckdb find_spec returns None
    - Foundry config types return their short driver name string from resolve_driver (no find_spec call)
    - create_adbc_connection catches adbc_driver_manager NOT_FOUND (or equivalent) and re-raises as ImportError with "https://docs.adbc-drivers.org/" in the message
    - create_adbc_connection accepts driver_path, kwargs, and optional entrypoint keyword argument
    - AdbcCreatorFn type alias defined in _pool_types.py
    - import adbc_poolhouse succeeds with no warehouse drivers installed
    - All type: ignore comments are in _driver_api.py and _pool_types.py only
  </done>
</task>

</tasks>

<verification>
Run prek on all four new wiring modules:

```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && prek run --all-files 2>&1 | tail -20
```

Verify DRIV-04 (lazy imports) — confirm no ADBC warehouse driver package names appear at top level of _drivers.py:

```bash
grep -n "^import adbc_driver\|^from adbc_driver" /Users/paul/Documents/Dev/Personal/adbc-poolhouse/src/adbc_poolhouse/_drivers.py
```

(Should return no results for warehouse-specific drivers. `adbc_driver_manager` in _driver_api.py is expected and correct.)

Verify _driver_api.py contains the Foundry NOT_FOUND catch-and-reraise with docs URL:

```bash
grep -n "docs.adbc-drivers.org\|NOT_FOUND\|ImportError" /Users/paul/Documents/Dev/Personal/adbc-poolhouse/src/adbc_poolhouse/_driver_api.py
```

Verify full import chain works:

```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "
from adbc_poolhouse._translators import translate_config
from adbc_poolhouse._drivers import resolve_driver
from adbc_poolhouse._driver_api import create_adbc_connection
from adbc_poolhouse._pool_types import AdbcCreatorFn
from adbc_poolhouse._duckdb_config import DuckDBConfig
r = translate_config(DuckDBConfig())
assert r == {'path': ':memory:'}
print('Phase 4 wiring layer complete')
"
```
</verification>

<success_criteria>
- translate_config() dispatches correctly to all 10 per-warehouse translators
- resolve_driver() implements 3-path logic: find_spec (PyPI), short name (Foundry), ImportError with install command
- create_adbc_connection() is the single location for all ADBC type suppressions AND catches NOT_FOUND from adbc_driver_manager, re-raising as ImportError with https://docs.adbc-drivers.org/ in the message
- _pool_types.py defines AdbcCreatorFn type alias; Phase 5 can import and use it
- prek passes with zero violations
- import adbc_poolhouse works in bare environment (no warehouse driver installed)
</success_criteria>

<output>
After completion, create `.planning/phases/04-translation-and-driver-detection/04-03-SUMMARY.md`
</output>
