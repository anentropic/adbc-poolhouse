---
phase: 04-translation-and-driver-detection
plan: "05"
type: tdd
wave: 3
depends_on:
  - "04-03"
files_modified:
  - tests/test_drivers.py
autonomous: true
requirements:
  - DRIV-01
  - DRIV-02
  - DRIV-03
  - DRIV-04
  - TEST-06

must_haves:
  truths:
    - "pytest tests/test_drivers.py passes with zero failures"
    - "Path 1 test: mock find_spec returns a mock spec with origin set — resolve_driver returns that origin path"
    - "Path 2 test: mock find_spec returns None for PyPI package — resolve_driver returns the package name (manifest fallback)"
    - "Path 3 test: DuckDB with find_spec returning None — ImportError raised with 'pip install adbc-poolhouse[duckdb]' in message"
    - "Foundry test: resolve_driver(DatabricksConfig()) returns 'databricks' without calling find_spec"
    - "Foundry NOT_FOUND test: create_adbc_connection() raises ImportError with 'https://docs.adbc-drivers.org/' when adbc_driver_manager raises NOT_FOUND for a Foundry driver (DRIV-03)"
    - "All tests use unittest.mock.patch — no real ADBC driver connection made"
  artifacts:
    - path: "tests/test_drivers.py"
      provides: "Driver detection unit tests covering all 3 paths and Foundry NOT_FOUND reraise"
      min_lines: 80
      contains: "class TestResolveDriver"
  key_links:
    - from: "tests/test_drivers.py"
      to: "adbc_poolhouse._drivers.resolve_driver"
      via: "direct import, mocked via unittest.mock.patch"
      pattern: "from adbc_poolhouse\\._drivers import resolve_driver"
    - from: "tests/test_drivers.py"
      to: "adbc_poolhouse._driver_api.create_adbc_connection"
      via: "direct import, adbc_driver_manager.dbapi.connect mocked"
      pattern: "from adbc_poolhouse\\._driver_api import create_adbc_connection"
    - from: "patch target"
      to: "importlib.util.find_spec"
      via: "unittest.mock.patch"
      pattern: "patch.*importlib\\.util\\.find_spec"
---

<objective>
TDD unit tests for driver detection (TEST-06). Tests cover all three detection paths using `unittest.mock.patch` to simulate driver presence/absence — no real ADBC driver connection is made. Tests also verify Foundry backends skip find_spec entirely and that `create_adbc_connection()` re-raises adbc_driver_manager NOT_FOUND as ImportError with https://docs.adbc-drivers.org/ (DRIV-03).

Purpose: Driver detection is the most complex logic in Phase 4 — it branches on driver type (PyPI vs Foundry), library presence, and must raise the correct ImportError format. Tests pin this behavior so Phase 5 integration can rely on it.

Output: `tests/test_drivers.py` with test classes covering all three paths, both driver categories, and the Foundry NOT_FOUND ImportError contract.
</objective>

<execution_context>
@/Users/paul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/paul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-translation-and-driver-detection/04-RESEARCH.md
@.planning/phases/04-translation-and-driver-detection/04-03-SUMMARY.md
@tests/conftest.py
</context>

<feature>
  <name>Driver detection unit tests (TEST-06)</name>
  <files>tests/test_drivers.py</files>
  <behavior>
All three detection paths must be tested for both PyPI and Foundry drivers. The Foundry NOT_FOUND → ImportError reraise from `create_adbc_connection()` must also be tested (DRIV-03).

**DuckDB — special case (TestResolveDuckDB):**
- Path 1 (found): `patch("importlib.util.find_spec", return_value=mock_spec)` where `mock_spec.origin = "/path/to/_duckdb.cpython-314-darwin.so"` → `resolve_driver(DuckDBConfig())` returns `"/path/to/_duckdb.cpython-314-darwin.so"`
- Path 3 (missing): `patch("importlib.util.find_spec", return_value=None)` → `resolve_driver(DuckDBConfig())` raises `ImportError` with message matching `"pip install adbc-poolhouse[duckdb]"`

**PyPI driver (e.g. Snowflake) — TestResolvePyPIDriver:**
- Path 1 (found): `patch("importlib.util.find_spec")` returns non-None spec AND `patch("builtins.__import__")` (or patch the specific module) → resolver calls `pkg._driver_path()` and returns its result
  - Alternatively: patch `adbc_poolhouse._drivers.importlib.util.find_spec` to return a mock spec, and patch `adbc_poolhouse._drivers.__import__` or mock the driver module via `sys.modules`
- Path 2 (missing from PyPI, may resolve via manifest): `patch("importlib.util.find_spec", return_value=None)` → `resolve_driver(SnowflakeConfig(account="a"))` returns `"adbc_driver_snowflake"` (the package name, for manifest fallback — not an ImportError, that's _driver_api.py's responsibility)

**Foundry driver — TestResolveFoundryDriver:**
- DatabricksConfig(): `resolve_driver(DatabricksConfig())` returns `"databricks"` — assert find_spec is NOT called (use `patch("importlib.util.find_spec") as mock_find_spec` and assert `mock_find_spec.assert_not_called()`)
- RedshiftConfig(): similarly returns `"redshift"`
- TeradataConfig(): returns `"teradata"` (LOW confidence name)

**Foundry NOT_FOUND → ImportError (TestCreateAdbcConnectionFoundryNotFound):**
Test that `create_adbc_connection()` converts adbc_driver_manager's NOT_FOUND error into a user-friendly `ImportError` containing the docs URL (DRIV-03, locked decision).

Strategy: patch `adbc_driver_manager.dbapi.connect` to raise the appropriate exception, then call `create_adbc_connection("databricks", {})` and assert the raised `ImportError` message contains `"https://docs.adbc-drivers.org/"`.

```python
class TestCreateAdbcConnectionFoundryNotFound:
    def test_foundry_not_found_raises_import_error_with_docs_url(self) -> None:
        """DRIV-03: Foundry NOT_FOUND -> ImportError with docs URL."""
        from adbc_poolhouse._driver_api import create_adbc_connection

        # Simulate what adbc_driver_manager raises when a manifest is missing.
        # Read _driver_api.py to confirm which exception class is caught,
        # then patch accordingly. Use Exception as the broadest safe default.
        not_found_exc = Exception("NOT_FOUND: no driver manifest for 'databricks'")

        with patch("adbc_driver_manager.dbapi.connect", side_effect=not_found_exc):
            with pytest.raises(ImportError, match=r"https://docs\.adbc-drivers\.org/"):
                create_adbc_connection("databricks", {})

    def test_foundry_not_found_message_contains_install_command(self) -> None:
        """DRIV-03: ImportError message includes dbc install command."""
        from adbc_poolhouse._driver_api import create_adbc_connection

        not_found_exc = Exception("NOT_FOUND: no driver manifest for 'databricks'")

        with patch("adbc_driver_manager.dbapi.connect", side_effect=not_found_exc):
            with pytest.raises(ImportError, match=r"dbc install databricks"):
                create_adbc_connection("databricks", {})
```

**IMPLEMENTATION NOTE for the Foundry NOT_FOUND tests:** Read `_driver_api.py` after Task 2 of 04-03 is complete to confirm the exact exception class being caught. If `_driver_api.py` catches `adbc_driver_manager.AdbcStatusCode`, the patch must raise that class (not a plain `Exception`). The test skeleton above uses plain `Exception("NOT_FOUND: ...")` which works if `_driver_api.py` has a broad `except Exception` fallback check on the error message. Adjust the raised exception class to match the actual implementation.

**TypeError for unknown config (TestResolveDriverEdgeCases):**
- Custom class not in dispatch map → TypeError raised

Test file structure:
```python
from __future__ import annotations

from unittest.mock import MagicMock, patch

import pytest

from adbc_poolhouse._databricks_config import DatabricksConfig
from adbc_poolhouse._duckdb_config import DuckDBConfig
from adbc_poolhouse._drivers import resolve_driver
from adbc_poolhouse._redshift_config import RedshiftConfig
from adbc_poolhouse._snowflake_config import SnowflakeConfig
from adbc_poolhouse._teradata_config import TeradataConfig


class TestResolveDuckDB:
    def test_path1_duckdb_found_via_find_spec(self) -> None:
        """Path 1: find_spec('_duckdb') returns spec with origin."""
        mock_spec = MagicMock()
        mock_spec.origin = "/path/to/_duckdb.cpython-314-darwin.so"
        with patch("importlib.util.find_spec", return_value=mock_spec):
            path = resolve_driver(DuckDBConfig())
        assert path == "/path/to/_duckdb.cpython-314-darwin.so"

    def test_path3_duckdb_missing_raises_import_error(self) -> None:
        """Path 3: find_spec returns None -> ImportError with install command."""
        with patch("importlib.util.find_spec", return_value=None):
            with pytest.raises(ImportError, match=r"pip install adbc-poolhouse\[duckdb\]"):
                resolve_driver(DuckDBConfig())


class TestResolvePyPIDriver:
    def test_path2_snowflake_missing_returns_package_name(self) -> None:
        """Path 2: find_spec None -> returns package name for manifest fallback."""
        with patch("importlib.util.find_spec", return_value=None):
            result = resolve_driver(SnowflakeConfig(account="a"))
        assert result == "adbc_driver_snowflake"


class TestResolveFoundryDriver:
    def test_databricks_returns_short_name_without_find_spec(self) -> None:
        """Foundry: resolve_driver returns driver name without calling find_spec."""
        with patch("importlib.util.find_spec") as mock_find:
            result = resolve_driver(DatabricksConfig())
        mock_find.assert_not_called()
        assert result == "databricks"

    def test_redshift_returns_short_name(self) -> None:
        result = resolve_driver(RedshiftConfig())
        assert result == "redshift"

    def test_teradata_returns_short_name(self) -> None:
        # LOW confidence: driver name 'teradata' inferred from pattern
        result = resolve_driver(TeradataConfig())
        assert result == "teradata"


class TestCreateAdbcConnectionFoundryNotFound:
    def test_foundry_not_found_raises_import_error_with_docs_url(self) -> None:
        """DRIV-03: Foundry NOT_FOUND -> ImportError with docs URL."""
        from adbc_poolhouse._driver_api import create_adbc_connection

        not_found_exc = Exception("NOT_FOUND: no driver manifest for 'databricks'")
        with patch("adbc_driver_manager.dbapi.connect", side_effect=not_found_exc):
            with pytest.raises(ImportError, match=r"https://docs\.adbc-drivers\.org/"):
                create_adbc_connection("databricks", {})

    def test_foundry_not_found_message_contains_install_command(self) -> None:
        """DRIV-03: ImportError message includes dbc install command."""
        from adbc_poolhouse._driver_api import create_adbc_connection

        not_found_exc = Exception("NOT_FOUND: no driver manifest for 'databricks'")
        with patch("adbc_driver_manager.dbapi.connect", side_effect=not_found_exc):
            with pytest.raises(ImportError, match=r"dbc install databricks"):
                create_adbc_connection("databricks", {})
```

Note on patch target: If `_drivers.py` uses `import importlib.util` at module level and then calls `importlib.util.find_spec()` inside functions, the correct patch target is `"importlib.util.find_spec"` (patches it globally). If `_drivers.py` imports `find_spec` directly (`from importlib.util import find_spec`), the patch target should be `"adbc_poolhouse._drivers.find_spec"`. Use whichever matches the actual import style in _drivers.py. Read _drivers.py to confirm before writing the patch targets.
  </behavior>
  <implementation>
Follow RED→GREEN→REFACTOR:

**RED:** Write test_drivers.py with all test classes. Run `pytest tests/test_drivers.py -x` — tests MUST fail (resolve_driver may not exist yet if running before 04-03). Commit: `test(04-05): add failing driver detection unit tests`

**GREEN:** Driver detection already implemented in 04-03. Run tests. Fix any patch target mismatches (check actual import style in _drivers.py). Fix resolve_driver or create_adbc_connection implementation if test expectations reveal bugs. For TestCreateAdbcConnectionFoundryNotFound: read _driver_api.py to confirm the exception class caught, then adjust the `side_effect` exception type in tests if needed. Commit: `feat(04-05): all driver detection tests pass`

**REFACTOR (if needed):** If patch targets are repeated across many tests, consider a helper or fixture. Keep tests readable — each test must clearly name what path it exercises. Commit: `refactor(04-05): clean up driver detection tests`
  </implementation>
</feature>

<verification>
```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && pytest tests/test_drivers.py -v 2>&1 | tail -30
```

```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && prek run --all-files 2>&1 | tail -20
```

Run all tests together to confirm no cross-test interference:

```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && pytest tests/ -v 2>&1 | tail -40
```
</verification>

<success_criteria>
- pytest tests/test_drivers.py passes with 0 failures
- Path 1, Path 2, Path 3 each have at least one test
- Foundry driver test asserts find_spec is NOT called
- ImportError message from resolve_driver contains exact install command format (pip install adbc-poolhouse[duckdb])
- ImportError from create_adbc_connection contains https://docs.adbc-drivers.org/ (DRIV-03)
- prek passes with zero violations
- pytest tests/ (all tests combined) passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-translation-and-driver-detection/04-05-SUMMARY.md`
</output>
