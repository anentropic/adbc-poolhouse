---
phase: 04-translation-and-driver-detection
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/adbc_poolhouse/_duckdb_translator.py
  - src/adbc_poolhouse/_bigquery_translator.py
  - src/adbc_poolhouse/_postgresql_translator.py
  - src/adbc_poolhouse/_flightsql_translator.py
autonomous: true
requirements:
  - TRANS-01
  - TRANS-03
  - TRANS-05

must_haves:
  truths:
    - "translate_duckdb(DuckDBConfig()) returns exactly {'path': ':memory:'}"
    - "translate_duckdb(DuckDBConfig(database='/tmp/t.db', read_only=True)) returns exactly {'path': '/tmp/t.db', 'access_mode': 'READ_ONLY'}"
    - "translate_bigquery returns only non-None config fields as ADBC key strings"
    - "translate_postgresql returns {'uri': '...'} with no use_copy key"
    - "translate_flightsql maps all FlightSQL config fields to their verified ADBC key strings"
    - "None of the four translator files contain any ADBC driver import at module level"
  artifacts:
    - path: "src/adbc_poolhouse/_duckdb_translator.py"
      provides: "translate_duckdb() pure function"
      exports: ["translate_duckdb"]
    - path: "src/adbc_poolhouse/_bigquery_translator.py"
      provides: "translate_bigquery() pure function"
      exports: ["translate_bigquery"]
    - path: "src/adbc_poolhouse/_postgresql_translator.py"
      provides: "translate_postgresql() pure function"
      exports: ["translate_postgresql"]
    - path: "src/adbc_poolhouse/_flightsql_translator.py"
      provides: "translate_flightsql() pure function"
      exports: ["translate_flightsql"]
  key_links:
    - from: "_duckdb_translator.py"
      to: "_duckdb_config.py"
      via: "import DuckDBConfig"
      pattern: "from adbc_poolhouse._duckdb_config import DuckDBConfig"
    - from: "translate_duckdb"
      to: "dict[str, str]"
      via: "return type annotation"
      pattern: "def translate_duckdb.*-> dict\\[str, str\\]"
---

<objective>
Implement pure translator functions for DuckDB (TRANS-01) and the three Apache ADBC backends — BigQuery, PostgreSQL, FlightSQL (TRANS-03). Each translator maps a typed config instance to a `dict[str, str]` of ADBC driver kwargs with no ADBC driver imports (TRANS-05).

Purpose: These translators are the core data-mapping layer — every `create_pool()` call (Phase 5) routes through them to get driver kwargs. The purity requirement (no ADBC imports) ensures the library is importable even without drivers installed.

Output: Four translator source files, each a single pure function.
</objective>

<execution_context>
@/Users/paul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/paul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-translation-and-driver-detection/04-RESEARCH.md
@src/adbc_poolhouse/_duckdb_config.py
@src/adbc_poolhouse/_bigquery_config.py
@src/adbc_poolhouse/_postgresql_config.py
@src/adbc_poolhouse/_flightsql_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: DuckDB and PostgreSQL translators</name>
  <files>
    src/adbc_poolhouse/_duckdb_translator.py
    src/adbc_poolhouse/_postgresql_translator.py
  </files>
  <action>
Create `src/adbc_poolhouse/_duckdb_translator.py`:

```python
from __future__ import annotations

from adbc_poolhouse._duckdb_config import DuckDBConfig


def translate_duckdb(config: DuckDBConfig) -> dict[str, str]:
    """Translate DuckDBConfig to ADBC driver kwargs.

    Returns:
        Dict with 'path' key (always) and 'access_mode' = 'READ_ONLY' when
        config.read_only is True. All values are strings.

    Note:
        DuckDB driver uses 'path' (not 'database') and 'access_mode' (not 'read_only').
        Entrypoint 'duckdb_adbc_init' must be passed separately to dbapi.connect().
        Verified against duckdb docs and live testing.
    """
    kwargs: dict[str, str] = {"path": config.database}
    if config.read_only:
        kwargs["access_mode"] = "READ_ONLY"
    return kwargs
```

Create `src/adbc_poolhouse/_postgresql_translator.py`:

```python
from __future__ import annotations

from adbc_poolhouse._postgresql_config import PostgreSQLConfig


def translate_postgresql(config: PostgreSQLConfig) -> dict[str, str]:
    """Translate PostgreSQLConfig to ADBC driver kwargs.

    Returns:
        Dict with 'uri' key (if set). May be empty if uri is None.

    Note:
        'adbc.postgresql.use_copy' is a StatementOptions key — it is NOT a
        database-level kwarg and cannot be passed to dbapi.connect(). The
        use_copy field is intentionally omitted here. Phase 5 must handle it
        at the cursor level if needed.
        Verified against installed adbc_driver_postgresql source.
    """
    kwargs: dict[str, str] = {}
    if config.uri is not None:
        kwargs["uri"] = config.uri
    return kwargs
```

Both files must begin with `from __future__ import annotations`. No ADBC driver imports anywhere in these files — only imports from `adbc_poolhouse._*_config` modules.
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "from adbc_poolhouse._duckdb_translator import translate_duckdb; from adbc_poolhouse._postgresql_translator import translate_postgresql; from adbc_poolhouse._duckdb_config import DuckDBConfig; from adbc_poolhouse._postgresql_config import PostgreSQLConfig; r1 = translate_duckdb(DuckDBConfig()); assert r1 == {'path': ':memory:'}, f'Got {r1}'; r2 = translate_postgresql(PostgreSQLConfig(uri='postgresql://localhost/db')); assert r2 == {'uri': 'postgresql://localhost/db'}, f'Got {r2}'; print('OK')" && python -c "import ast, sys; ast.parse(open('src/adbc_poolhouse/_duckdb_translator.py').read()); ast.parse(open('src/adbc_poolhouse/_postgresql_translator.py').read()); print('AST OK')"</automated>
    <manual>Confirm no ADBC driver module names appear in either file (grep for adbc_driver_duckdb, adbc_driver_postgresql)</manual>
  </verify>
  <done>
    - translate_duckdb(DuckDBConfig()) returns {"path": ":memory:"}
    - translate_duckdb(DuckDBConfig(database="/tmp/t.db", read_only=True)) returns {"path": "/tmp/t.db", "access_mode": "READ_ONLY"}
    - translate_postgresql(PostgreSQLConfig(uri="postgresql://localhost/db")) returns {"uri": "postgresql://localhost/db"}
    - Neither file imports any adbc_driver_* module at module level
  </done>
</task>

<task type="auto">
  <name>Task 2: BigQuery and FlightSQL translators</name>
  <files>
    src/adbc_poolhouse/_bigquery_translator.py
    src/adbc_poolhouse/_flightsql_translator.py
  </files>
  <action>
Create `src/adbc_poolhouse/_bigquery_translator.py`:

```python
from __future__ import annotations

from adbc_poolhouse._bigquery_config import BigQueryConfig


def translate_bigquery(config: BigQueryConfig) -> dict[str, str]:
    """Translate BigQueryConfig to ADBC driver kwargs.

    All keys verified from installed adbc_driver_bigquery.DatabaseOptions enum.
    Only non-None fields are included in the output dict.
    """
    kwargs: dict[str, str] = {}
    if config.auth_type is not None:
        kwargs["adbc.bigquery.sql.auth_type"] = config.auth_type
    if config.auth_credentials is not None:
        kwargs["adbc.bigquery.sql.auth_credentials"] = config.auth_credentials.get_secret_value()
    if config.auth_client_id is not None:
        kwargs["adbc.bigquery.sql.auth.client_id"] = config.auth_client_id
    if config.auth_client_secret is not None:
        kwargs["adbc.bigquery.sql.auth.client_secret"] = config.auth_client_secret.get_secret_value()
    if config.auth_refresh_token is not None:
        kwargs["adbc.bigquery.sql.auth.refresh_token"] = config.auth_refresh_token.get_secret_value()
    if config.project_id is not None:
        kwargs["adbc.bigquery.sql.project_id"] = config.project_id
    if config.dataset_id is not None:
        kwargs["adbc.bigquery.sql.dataset_id"] = config.dataset_id
    return kwargs
```

Create `src/adbc_poolhouse/_flightsql_translator.py`. Map each FlightSQLConfig field to its ADBC key using the exact key strings from the RESEARCH.md key reference table:

- `uri` → `"uri"` (str, include if not None)
- `username` → `"username"` (str)
- `password` → `"password"` (SecretStr, .get_secret_value())
- `authorization_header` → `"adbc.flight.sql.authorization_header"` (SecretStr)
- `mtls_cert_chain` → `"adbc.flight.sql.client_option.mtls_cert_chain"` (str)
- `mtls_private_key` → `"adbc.flight.sql.client_option.mtls_private_key"` (SecretStr)
- `tls_root_certs` → `"adbc.flight.sql.client_option.tls_root_certs"` (str)
- `tls_skip_verify` → `"adbc.flight.sql.client_option.tls_skip_verify"` (bool → `str(val).lower()`)
- `tls_override_hostname` → `"adbc.flight.sql.client_option.tls_override_hostname"` (str)
- `connect_timeout` → `"adbc.flight.sql.rpc.timeout_seconds.connect"` (float → str; NOT in Python enum, use raw string key per RESEARCH.md)
- `query_timeout` → `"adbc.flight.sql.rpc.timeout_seconds.query"` (float → str)
- `fetch_timeout` → `"adbc.flight.sql.rpc.timeout_seconds.fetch"` (float → str)
- `update_timeout` → `"adbc.flight.sql.rpc.timeout_seconds.update"` (float → str)
- `authority` → `"adbc.flight.sql.client_option.authority"` (str)
- `max_msg_size` → `"adbc.flight.sql.client_option.with_max_msg_size"` (int → str)
- `with_cookie_middleware` → `"adbc.flight.sql.rpc.with_cookie_middleware"` (bool → `str(val).lower()`)

Rules:
1. All optional fields (including `tls_skip_verify` which is a bool with a default) — only include in output when not None. Check FlightSQLConfig field definitions; include only non-None values.
2. All output values must be `str` — use `.get_secret_value()` for SecretStr, `str(val).lower()` for bool, `str(val)` for int/float.
3. No ADBC driver imports anywhere in this file.
4. Add a docstring noting: "connect_timeout uses raw string key 'adbc.flight.sql.rpc.timeout_seconds.connect' which is documented in ADBC FlightSQL docs but absent from the Python DatabaseOptions enum."

Begin file with `from __future__ import annotations`.
  </action>
  <verify>
    <automated>cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "
from adbc_poolhouse._bigquery_translator import translate_bigquery
from adbc_poolhouse._flightsql_translator import translate_flightsql
from adbc_poolhouse._bigquery_config import BigQueryConfig
from adbc_poolhouse._flightsql_config import FlightSQLConfig

# BigQuery: empty config returns empty dict
r1 = translate_bigquery(BigQueryConfig())
assert r1 == {}, f'BigQuery empty config: got {r1}'

# BigQuery: project_id included
r2 = translate_bigquery(BigQueryConfig(project_id='my-project'))
assert r2 == {'adbc.bigquery.sql.project_id': 'my-project'}, f'BigQuery project_id: got {r2}'

# FlightSQL: empty config returns empty dict (all fields optional)
r3 = translate_flightsql(FlightSQLConfig())
assert isinstance(r3, dict), 'FlightSQL must return dict'
all_str = all(isinstance(k, str) and isinstance(v, str) for k, v in r3.items())
assert all_str, f'All values must be str: {r3}'

# FlightSQL: uri set
r4 = translate_flightsql(FlightSQLConfig(uri='grpc://localhost:32010'))
assert r4.get('uri') == 'grpc://localhost:32010', f'FlightSQL uri: got {r4}'

print('OK')
"</automated>
    <manual>Verify _flightsql_translator.py has no adbc_driver_flightsql import. Confirm tls_skip_verify produces "true"/"false" strings.</manual>
  </verify>
  <done>
    - translate_bigquery(BigQueryConfig()) returns {}
    - translate_bigquery(BigQueryConfig(project_id="my-project")) returns exactly {"adbc.bigquery.sql.project_id": "my-project"}
    - translate_flightsql(FlightSQLConfig(uri="grpc://localhost:32010")) returns dict containing {"uri": "grpc://localhost:32010"}
    - All values in FlightSQL output are str type (no booleans, ints, or None)
    - Neither file imports any ADBC driver package
  </done>
</task>

</tasks>

<verification>
Run prek to confirm no ruff, pyright, or other tool violations introduced by the four new translator files:

```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && prek run --all-files 2>&1 | tail -20
```

All four translator files must be importable in an environment without warehouse drivers installed:

```bash
cd /Users/paul/Documents/Dev/Personal/adbc-poolhouse && python -c "
from adbc_poolhouse._duckdb_translator import translate_duckdb
from adbc_poolhouse._bigquery_translator import translate_bigquery
from adbc_poolhouse._postgresql_translator import translate_postgresql
from adbc_poolhouse._flightsql_translator import translate_flightsql
print('All translators importable')
"
```
</verification>

<success_criteria>
- translate_duckdb, translate_bigquery, translate_postgresql, translate_flightsql all defined and importable
- Each returns dict[str, str] with no None values and no non-string values
- No ADBC driver package imported at module level in any of the four files
- prek passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/04-translation-and-driver-detection/04-01-SUMMARY.md`
</output>
